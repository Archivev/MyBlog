<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JDK8源码--String.trim()</title>
      <link href="/2020/05/14/JDK8%E6%BA%90%E7%A0%81/JDK8%E6%BA%90%E7%A0%81--String.trim()/"/>
      <url>/2020/05/14/JDK8%E6%BA%90%E7%A0%81/JDK8%E6%BA%90%E7%A0%81--String.trim()/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK8源码–String-trim"><a href="#JDK8源码–String-trim" class="headerlink" title="JDK8源码–String.trim()"></a>JDK8源码–String.trim()</h1><blockquote><p>一直以来，学习 Java 的路上被无数次的告知<code>String</code>类下的<code>trim()</code>方法时，这个函数的作用是去除字符串两边的空格的。但是无意间打开他的源码却发现并没有只是去除空格那么简单，下面来简单分析下，<a href="https://blog.csdn.net/leeqihe/article/details/81006611" target="_blank" rel="noopener">参考链接</a></p></blockquote><h2 id="trim-方法去掉了哪些字符？"><a href="#trim-方法去掉了哪些字符？" class="headerlink" title="trim()方法去掉了哪些字符？"></a>trim()方法去掉了哪些字符？</h2><p>先看下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"abc\u001E\u001E\u001E\u001F\u001F\u001F"</span>;</span><br><span class="line">System.out.println(str);</span><br><span class="line">str = str.trim();</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure><p>这是在 IDEA 上的效果，我们把他输出一下：</p><p><img alt="image-20200514104410797" data-src="https://cdn.kaiming66.com/JDK8%E6%BA%90%E7%A0%81-image-20200514104410797.png" class="lazyload"></p><p>会发现，这个看似乱码的字符被<code>trim()</code>干掉了，我们看一下他的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">trim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个 value 是 String 里的 final char[]</span></span><br><span class="line">        <span class="keyword">int</span> len = value.length;</span><br><span class="line">        <span class="keyword">int</span> st = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] val = value;    <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[st] &lt;= <span class="string">' '</span>)) &#123;</span><br><span class="line">            st++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[len - <span class="number">1</span>] &lt;= <span class="string">' '</span>)) &#123;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ((st &gt; <span class="number">0</span>) || (len &lt; value.length)) ? substring(st, len) : <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>原文的”white space“中文直译为”留白“或”空白“，但是常见文档一般翻译为”空格“，而空格的英文一般应译为”blank”或”space”，所以我认为这里的翻译不够准确（当然源码注解也没有写得很清楚），而且会引起歧义。</p><p><strong>trim()方法实际上trim掉了字符串两端Unicode编码小于等于32（\u0020）的所有字符。</strong></p><p>现在提出另一个问题：</p><h2 id="trim-substring-怎样返回字符串对象？"><a href="#trim-substring-怎样返回字符串对象？" class="headerlink" title="trim()/substring()怎样返回字符串对象？"></a>trim()/substring()怎样返回字符串对象？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str1 = <span class="string">"abc   "</span>;</span><br><span class="line">    String str2 = <span class="string">"abc"</span>;</span><br><span class="line">    String str3 = <span class="string">"abc"</span>;</span><br><span class="line">    str1 = str1.trim();</span><br><span class="line">    System.out.println(str1 == str2);  <span class="comment">// false</span></span><br><span class="line">    System.out.println(str3 == str2);  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>str1.trim()返回的字符串为”abc”，而在常量池中已经确定存在这个”abc”这个String对象，那为何str1==str2不成立呢？<br>我们看trim()方法的最后一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ((st &gt; <span class="number">0</span>) || (len &lt; value.length)) ? substring(st, len) : <span class="keyword">this</span>;</span><br></pre></td></tr></table></figure><p>也就是说，<strong>trim()方法实际上的行为并不是”去掉两端的空白字符“，而是”截取中间的非空白字符“</strong>。<br>再看substring()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endIndex &gt; value.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> subLen = endIndex - beginIndex;</span><br><span class="line">    <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意这一行会 new String </span></span><br><span class="line">    <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="keyword">this</span></span><br><span class="line">        : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，当实际发生了”截取“这个动作的时候，因为此处无法直接声明一个String常量，即substring()无法像我们写String str = “abc”这样直接在常量池中创建对象，所以它返回的是一个new出来的对象，这个对象位于Heap内存中。</p>]]></content>
      
      
      <categories>
          
          <category> JDK8源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JDK8源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch--简单入门</title>
      <link href="/2020/05/12/ElasticSearch/ElasticSearch%E5%85%A5%E9%97%A8/"/>
      <url>/2020/05/12/ElasticSearch/ElasticSearch%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="ElasticSearch–简单入门"><a href="#ElasticSearch–简单入门" class="headerlink" title="ElasticSearch–简单入门"></a>ElasticSearch–简单入门</h1><blockquote><p>总结于同学大佬的<a href="https://blog.csdn.net/weixin_44588495/article/details/103192940" target="_blank" rel="noopener">学习ElasticSearch</a>，以及慕课网一些教程</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;Elaticsearch ,简称为es，es是一个开源的高扩展的分布式全文检索引擎,它可以近乎实时的存储、检索数据;本身扩展性很好,可以扩展到上百台服务器,处理PB级别的数据。es也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能,但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性,从而让全文搜索变得变得简单。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p> 因为用是 win 本，mac 的没怎么用过，这里说一下 win 下的安装</p></blockquote><ul><li>可以选择去<a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener">官网下载</a>你想要的版本（下图所示位置），因为一般用的都是 5.x 版本的，新版本会有些旧命令不兼容</li></ul><p><img alt="image-20200512112807928" data-src="https://cdn.kaiming66.com/es_image-20200512112807928.png" class="lazyload"></p><ul><li>当然这里下载是比较慢的，百度网盘的应该会快一点吧，我把他上传到了网盘上。（<a href="https://pan.baidu.com/s/1YUG8kP4xgSzWNmDjdJLPAA" target="_blank" rel="noopener">点击下载</a>，提取码：0qc5）</li><li>JDK 版本要求为 1.8 以上，默认占用端口 9300，9200</li><li>解压下载好的文件，进入 bin 目录点击启动脚本启动（我这里是 5.6.10 版本）</li></ul><p><img alt="image-20200512113247389" data-src="https://cdn.kaiming66.com/es_image-20200512113247389.png" class="lazyload"></p><ul><li>浏览器输入 localhost:9200（我这里是改了下端口，后续测试集群改的，改不改无所谓的）</li></ul><p><img alt="image-20200512113408506" data-src="https://cdn.kaiming66.com/es_image-20200512113408506.png" class="lazyload"></p><h2 id="安装可视化管理工具"><a href="#安装可视化管理工具" class="headerlink" title="安装可视化管理工具"></a>安装可视化管理工具</h2><ul><li>ES 本身并没有友好的管理界面，下载 ElasticSearch-head 插件可以更好的管理 ES</li><li>下载地址：<a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener">https://github.com/mobz/elasticsearch-head</a></li><li>下载并解压完成后，如下图所示：</li></ul><p><img alt="image-20200512113805480" data-src="https://cdn.kaiming66.com/es_image-20200512113805480.png" class="lazyload"></p><ul><li>因为他本身需要 Node.js 运行环境，这里不再赘述如何安装 Node.js ，在当前这个 head 文件夹这里打开命令行或者 powershell 按顺序执行下面语句（<code>注意一定要在 head 这个文件夹内操作</code>）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g grunt-cli</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" data-src="https://cdn.kaiming66.com/es-20191122095043521.png" class="lazyload"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grunt server</span><br></pre></td></tr></table></figure><ul><li>在浏览器里输入 localhost:9100 就可以看到图形化界面了</li></ul><p><img alt="在这里插入图片描述" data-src="https://cdn.kaiming66.com/es-20191122230031766.png" class="lazyload"></p><ul><li>连接前还需配置一下 es 的配置文件 ==》elasticsearch-5.6.10\config\elasticsearch.yml</li><li>在文件末尾加入下面两句话：</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">"*"</span></span><br></pre></td></tr></table></figure><ul><li>重启 es，连接成功</li></ul><p><img alt="在这里插入图片描述" data-src="https://cdn.kaiming66.com/es-20191122230937536.png" class="lazyload"></p><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><ul><li>可以直接在 head 内的复合查询里写 json 语句进行创建，也可以通过 postman 创建，因为 es 支持 restful 风格的接口进行访问，或者可以在 head 索引那里直接创建，不过这样创建的就是 非结构化的索引，即 mappings 里是空的。</li></ul><h3 id="postman"><a href="#postman" class="headerlink" title="postman"></a>postman</h3><p><img alt="image-20200512144007062" data-src="https://cdn.kaiming66.com/es_image-20200512144007062.png" class="lazyload"></p><p>&emsp;&emsp;可以看出结构很清晰，restful 风格访问 9200 端口，用<code>put</code>创建一个叫 blog 的索引（删除是<code>delete</code>），然后 json 形式设置 mappings 结构，里面会再细分比如说 articles 文章类型，然后规定 文章类型 的各种属性，id、title、content 等等，然后这些属性也可以再定义更细的类型，分词策略等等。</p><p>这里可以和<code>MySQL</code>数据库进行类比：</p><ul><li>索引（blog）就相当于 MySQL 的 database</li><li>类型（articles）相当于 table</li><li>文档 相当于 一条 score 记录，是可以被索引到的最基本的数据</li></ul><p>&emsp;&emsp;下面那个 settings，就是设置分片的个数和分片备份的个数，默认就是分片是 5，备份数为 1。</p><p><img alt="image-20200512144348371" data-src="https://cdn.kaiming66.com/es_image-20200512144341959.png" class="lazyload"></p><p>&emsp;&emsp;五个分片分别对应 0,1,2,3,4，而备份就是下面这个 框 比较细的 1,2，这个就是对 1,2 分片的备份。而框比较粗的就是真正的分片。</p><h2 id="集成分词器"><a href="#集成分词器" class="headerlink" title="集成分词器"></a>集成分词器</h2><ul><li>下载 <code>elasticsearch-analysis-ik-5.6.10</code> ，注意版本与 es 版本保持一致。（<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases?after=v5.6.14" target="_blank" rel="noopener">下载地址</a>）</li><li>下载解压出来的所有文件，粘贴到新建的一个目录下，ik-analyzer 文件夹下（这个是新建的）</li></ul><p><img alt="image-20200512145153364" data-src="https://cdn.kaiming66.com/es_image-20200512145153364.png" class="lazyload"></p><p>这里提供两种分词策略：</p><h3 id="ik-smart-为最少切分"><a href="#ik-smart-为最少切分" class="headerlink" title="ik-smart 为最少切分"></a>ik-smart 为最少切分</h3><p><img alt="image-20200512145419567" data-src="https://cdn.kaiming66.com/es_image-20200512145419567.png" class="lazyload"></p><p>测试结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"tokens"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"token"</span>: <span class="string">"我"</span>,</span><br><span class="line">            <span class="attr">"start_offset"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"end_offset"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"CN_CHAR"</span>,</span><br><span class="line">            <span class="attr">"position"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"token"</span>: <span class="string">"是"</span>,</span><br><span class="line">            <span class="attr">"start_offset"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"end_offset"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"CN_CHAR"</span>,</span><br><span class="line">            <span class="attr">"position"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"token"</span>: <span class="string">"河北"</span>,</span><br><span class="line">            <span class="attr">"start_offset"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">"end_offset"</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"CN_WORD"</span>,</span><br><span class="line">            <span class="attr">"position"</span>: <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"token"</span>: <span class="string">"大学"</span>,</span><br><span class="line">            <span class="attr">"start_offset"</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="attr">"end_offset"</span>: <span class="number">6</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"CN_WORD"</span>,</span><br><span class="line">            <span class="attr">"position"</span>: <span class="number">3</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"token"</span>: <span class="string">"青年"</span>,</span><br><span class="line">            <span class="attr">"start_offset"</span>: <span class="number">6</span>,</span><br><span class="line">            <span class="attr">"end_offset"</span>: <span class="number">8</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"CN_WORD"</span>,</span><br><span class="line">            <span class="attr">"position"</span>: <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ik-max-word-为最精细切分"><a href="#ik-max-word-为最精细切分" class="headerlink" title="ik-max-word 为最精细切分"></a>ik-max-word 为最精细切分</h3><p><img alt="image-20200512145534680" data-src="https://cdn.kaiming66.com/es_image-20200512145534680.png" class="lazyload"></p><p>结果略过，会尽可能切分组合成新词</p><h3 id="新建索引库"><a href="#新建索引库" class="headerlink" title="新建索引库"></a>新建索引库</h3><p>&emsp;&emsp;以后我们创建索引库就可以这样指定分词器进行创建：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"mappings"</span>:&#123;</span><br><span class="line"><span class="attr">"hello"</span>:&#123;</span><br><span class="line"><span class="attr">"properties"</span>:&#123;</span><br><span class="line"><span class="attr">"id"</span>:&#123;</span><br><span class="line"><span class="attr">"type"</span>:<span class="string">"long"</span>,</span><br><span class="line"><span class="attr">"store"</span>:<span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"title"</span>:&#123;</span><br><span class="line"><span class="attr">"type"</span>:<span class="string">"text"</span>,</span><br><span class="line"><span class="attr">"store"</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="attr">"analyzer"</span>:<span class="string">"ik_smart"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"content"</span>:&#123;</span><br><span class="line"><span class="attr">"type"</span>:<span class="string">"text"</span>,</span><br><span class="line"><span class="attr">"store"</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="attr">"analyzer"</span>:<span class="string">"ik_smart"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h2><p>&emsp;&emsp;ES 的集群配置还是比较简单的，在 config 下的 elasticsearch.yml 进行修改：</p><h3 id="master节点配置"><a href="#master节点配置" class="headerlink" title="master节点配置"></a>master节点配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#集群名称：保证一个集群的都是一样的</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">my-elasticsearch</span></span><br><span class="line"><span class="comment">#节点名称：必须不一样，主节点就可以叫 master，从机就可以交 slave</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">master</span></span><br><span class="line"><span class="comment">#节点是否可以成为 master，默认是 true，也就是不写的话默认每个机器都可以是 master</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#节点是否可以保存数据，默认开启，master一般就关了只负责维护集群</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#必须为本机ip地址</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="comment">#服务端口号，在同一机器下必须不一样</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="comment">#集群间通信的端口号，在同一机器下必须不一样</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9300</span></span><br><span class="line"><span class="comment">#设置集群自动发现机器ip集合</span></span><br><span class="line"><span class="attr">discovery.zen.ping.unicast.hosts:</span> <span class="string">["127.0.0.1:9300","127.0.0.1:9301","127.0.0.1:902"]</span></span><br></pre></td></tr></table></figure><h3 id="slave节点配置"><a href="#slave节点配置" class="headerlink" title="slave节点配置"></a>slave节点配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#集群名称：保证唯一</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">my-elasticsearch</span></span><br><span class="line"><span class="comment">#节点名称：必须不一样</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">slave1</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment">#必须为本机ip地址</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="comment">#服务端口号，在同一机器下必须不一样</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9201</span></span><br><span class="line"><span class="comment">#集群间通信的端口号，在同一机器下必须不一样</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9301</span></span><br><span class="line"><span class="comment">#设置集群自动发现机器ip集合</span></span><br><span class="line"><span class="attr">discovery.zen.ping.unicast.hosts:</span> <span class="string">["127.0.0.1:9300","127.0.0.1:9301","127.0.0.1:9302"]</span></span><br></pre></td></tr></table></figure><h3 id="完整配置"><a href="#完整配置" class="headerlink" title="完整配置"></a>完整配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">在生产环境下，如果不修改elasticsearch节点的角色信息，在高数据量，高并发的场景下集群容易出现脑裂等问题。</span></span><br><span class="line"><span class="string">默认情况下，elasticsearch集群中每个节点都有成为主节点的资格，也都存储数据，还可以提供查询服务。</span></span><br><span class="line"><span class="string">这些功能是由两个属性控制的。</span></span><br><span class="line"><span class="string">node.master和node.data</span></span><br><span class="line"><span class="string">默认情况下这两个属性的值都是true。</span></span><br><span class="line"><span class="string">下面详细介绍一下这两个属性的含义以及不同组合可以达到的效果。</span></span><br><span class="line"><span class="string">node.master：这个属性表示节点是否具有成为主节点的资格</span></span><br><span class="line"><span class="string">注意：此属性的值为true，并不意味着这个节点就是主节点。</span></span><br><span class="line"><span class="string">因为真正的主节点，是由多个具有主节点资格的节点进行选举产生的。</span></span><br><span class="line"><span class="string">所以，这个属性只是代表这个节点是不是具有主节点选举资格。</span></span><br><span class="line"><span class="string">node.data：这个属性表示节点是否存储数据。</span></span><br><span class="line"><span class="string">这两个属性可以有四种组合：</span></span><br><span class="line"><span class="string">第一种：这种组合表示这个节点即有成为主节点的资格，又存储数据，</span></span><br><span class="line"><span class="string">这个时候如果某个节点被选举成为了真正的主节点，那么他还要存储数据，这样对于这个节点的压力就比较大了。</span></span><br><span class="line"><span class="string">elasticsearch默认每个节点都是这样的配置，在测试环境下这样做没问题。实际工作中建议不要这样设置，</span></span><br><span class="line"><span class="string">这样相当于主节点和数据节点的角色混合到一块了。</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">第二种：这种组合表示这个节点没有成为主节点的资格，也就不参与选举，只会存储数据。</span></span><br><span class="line"><span class="string">这个节点我们称为data(数据)节点。在集群中需要单独设置几个这样的节点负责存储数据。后期提供存储和查询服务。</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">第三种：这种组合表示这个节点不会存储数据，有成为主节点的资格，可以参与选举，有可能成为真正的主节点。</span></span><br><span class="line"><span class="string">这个节点我们称为master节点</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">false</span></span><br><span class="line"><span class="string">第四种：这种组合表示这个节点即不会成为主节点，也不会存储数据，</span></span><br><span class="line"><span class="string">这个节点的意义是作为一个client(客户端)节点，主要是针对海量请求的时候可以进行负载均衡。</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">false</span></span><br><span class="line"><span class="string">默认情况下，每个节点都有成为主节点的资格，也会存储数据，还会处理客户端的请求。</span></span><br><span class="line"><span class="string">在一个生产集群中我们可以对这些节点的职责进行划分。</span></span><br><span class="line"><span class="string">建议集群中设置3台以上的节点作为master节点【node.master:</span> <span class="attr">true node.data:</span> <span class="literal">false</span><span class="string">】</span></span><br><span class="line"><span class="string">这些节点只负责成为主节点，维护整个集群的状态。</span></span><br><span class="line"><span class="string">再根据数据量设置一批data节点【node.master:</span> <span class="attr">false node.data:</span> <span class="literal">true</span><span class="string">】</span></span><br><span class="line"><span class="string">这些节点只负责存储数据，后期提供建立索引和查询索引的服务，这样的话如果用户请求比较频繁，这些节点的压力也会比较大</span></span><br><span class="line"><span class="string">所以在集群中建议再设置一批client节点【node.master:</span> <span class="attr">false node.data:</span> <span class="literal">false</span><span class="string">】</span></span><br><span class="line"><span class="string">这些节点只负责处理用户请求，实现请求转发，负载均衡等功能。</span></span><br><span class="line"><span class="string">master节点：普通服务器即可(CPU</span> <span class="string">内存</span> <span class="string">消耗一般)</span></span><br><span class="line"><span class="string">data节点：主要消耗磁盘，内存</span></span><br><span class="line"><span class="string">client节点：普通服务器即可(如果要进行分组聚合操作的话，建议这个节点内存也分配多一点)</span></span><br></pre></td></tr></table></figure><h3 id="配置效果"><a href="#配置效果" class="headerlink" title="配置效果"></a>配置效果</h3><p><img alt="image-20200512150421529" data-src="https://cdn.kaiming66.com/es_image-20200512150421529.png" class="lazyload"></p>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式--记一次搭建RPC框架</title>
      <link href="/2020/03/06/Distributed/%E5%88%86%E5%B8%83%E5%BC%8F--%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BARPC%E6%A1%86%E6%9E%B6/"/>
      <url>/2020/03/06/Distributed/%E5%88%86%E5%B8%83%E5%BC%8F--%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BARPC%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式–记一次搭建RPC框架"><a href="#分布式–记一次搭建RPC框架" class="headerlink" title="分布式–记一次搭建RPC框架"></a>分布式–记一次搭建RPC框架</h1><blockquote><p>基于 Springboot + zookeeper + dubbo 框架，所用 IDE 为 IDEA</p></blockquote><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>&emsp;&emsp;整体结构并不复杂，provider 和 consumer 都依赖于 service 项目，在 service 中我们可以创建一些共用的组件，比如说工具类、BaseEntity、AjaxResult 等等。然后就是一些实体类和规定对应的 servcie 接口，并不提供实现方法。而 provider 中则负责实现 service 中的接口并有对数据库进行操作的 mapper 及 xml 文件。consumer 就负责与前端数据做交互，里面有 RestController 。在 consumer 和 provider 中都需要通过 dubbo 与 zookeeper 建立连接。</p><ul><li>zookeeper 开放 2181 端口给 provider、consumer、dubbo-admin</li><li>provider的20880开放给所有consumer，但8080服务器端口可以完全屏蔽</li><li>consumer的8080开放给所有provider</li><li>dubbo-admin的8080开放给管理员用户，便于通过浏览器监控注册中心服务的情况</li></ul><p>&emsp;&emsp;consumer 向 zk 订阅服务，provider 向 zk 注册服务。zk 接受到新注册的服务会告知订阅服务的 consumer，而这时<strong>消费者和生产者之间就变成了点对点的通信是由 consumer 直接调用 provider</strong>，不经过 zk 这样效率更高。</p><p><img alt="20160823142315665" data-src="https://cdn.kaiming66.com/%E5%88%86%E5%B8%83%E5%BC%8F-20160823142315665.jpg" class="lazyload"></p><p><img alt="image-20200306102929880" data-src="https://cdn.kaiming66.com/%E5%88%86%E5%B8%83%E5%BC%8F-image-20200306102929880.png" class="lazyload"></p><h2 id="创建整个文件结构"><a href="#创建整个文件结构" class="headerlink" title="创建整个文件结构"></a>创建整个文件结构</h2><h3 id="第一步：创建一个空项目"><a href="#第一步：创建一个空项目" class="headerlink" title="第一步：创建一个空项目"></a>第一步：创建一个空项目</h3><p><img alt="image-20200306101355511" data-src="https://cdn.kaiming66.com/%E5%88%86%E5%B8%83%E5%BC%8F-image-20200306101355511.png" class="lazyload"></p><h3 id="第二步：创建-service、consumer、provider-三个-Module-Maven-工程"><a href="#第二步：创建-service、consumer、provider-三个-Module-Maven-工程" class="headerlink" title="第二步：创建 service、consumer、provider 三个 Module Maven 工程"></a>第二步：创建 service、consumer、provider 三个 Module Maven 工程</h3><ul><li>快捷键 crtl + alt + shift + s，打开 Projcet Structure 界面，点击加号创建</li></ul><p><img alt="image-20200306102139824" data-src="https://cdn.kaiming66.com/%E5%88%86%E5%B8%83%E5%BC%8F-image-20200306102139824.png" class="lazyload"></p><ul><li>创建一个 Maven 项目</li></ul><p><img alt="image-20200306114848933" data-src="https://cdn.kaiming66.com/%E5%88%86%E5%B8%83%E5%BC%8F-image-20200306114848933.png" class="lazyload"></p><h3 id="第三步：编写-Service"><a href="#第三步：编写-Service" class="headerlink" title="第三步：编写 Service"></a>第三步：编写 Service</h3><p><img alt="image-20200306103307682" data-src="https://cdn.kaiming66.com/%E5%88%86%E5%B8%83%E5%BC%8F-image-20200306103307682.png" class="lazyload"></p><h4 id="Pom-文件"><a href="#Pom-文件" class="headerlink" title="Pom 文件"></a>Pom 文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.archiver.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo.version</span>&gt;</span>2.7.3<span class="tag">&lt;/<span class="name">dubbo.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--commons --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.54<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;dubbo.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;dubbo.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>common 中写一些共用的组件</li></ul><h4 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h4><p>然后按照自己的习惯创建一个实体类，必须实现序列化接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span>(callSuper = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@TableName</span>(<span class="string">"t_student"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField</span>(<span class="string">"user_name"</span>)</span><br><span class="line">    String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField</span>(<span class="string">"sex"</span>)</span><br><span class="line">    String sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField</span>(<span class="string">"status"</span>)</span><br><span class="line">    String status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Service-接口"><a href="#Service-接口" class="headerlink" title="Service 接口"></a>Service 接口</h4><p>这里我用的是 mybatis-plus</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IStudentService</span> <span class="keyword">extends</span> <span class="title">IService</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">index</span><span class="params">(Student student)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第四步：编写-provider"><a href="#第四步：编写-provider" class="headerlink" title="第四步：编写 provider"></a>第四步：编写 provider</h3><p><img alt="image-20200306103339341" data-src="https://cdn.kaiming66.com/%E5%88%86%E5%B8%83%E5%BC%8F-image-20200306103339341.png" class="lazyload"></p><p>按照上面的步骤再创建一个 module 名字是 provider，这里写具体的实现方法以及对应 mapper</p><h4 id="Pom文件（注意里面要依赖-service-项目）"><a href="#Pom文件（注意里面要依赖-service-项目）" class="headerlink" title="Pom文件（注意里面要依赖 service 项目）"></a>Pom文件（注意里面要依赖 service 项目）</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.archiver.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.archiver.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Druid数据源 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="ServiceImpl"><a href="#ServiceImpl" class="headerlink" title="ServiceImpl"></a>ServiceImpl</h4><ul><li>注意这里的注解不是 mvc 中的注解，是 dubbo 中的 service 注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.dubbo.config.annotation.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">StudentMapper</span>, <span class="title">Student</span>&gt; <span class="keyword">implements</span> <span class="title">IStudentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">index</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里我只让他在控制台输出了一句话</span></span><br><span class="line">        System.out.println(<span class="string">"冲冲冲"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mapper"><a href="#mapper" class="headerlink" title="mapper"></a>mapper</h4><ul><li>StudentMapper</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>StudentMapper.xml</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.archiver.provider.student.mapper.StudentMapper"</span>&gt;</span><br><span class="line">    &lt;resultMap id=<span class="string">"BaseResultMap"</span> type=<span class="string">"com.archiver.service.student.entity.Student"</span>&gt;</span><br><span class="line">        &lt;id column=<span class="string">"id"</span> jdbcType=<span class="string">"INTEGER"</span> property=<span class="string">"id"</span> /&gt;</span><br><span class="line">        &lt;id column=<span class="string">"user_name"</span> jdbcType=<span class="string">"VARCHAR"</span> property=<span class="string">"userName"</span> /&gt;</span><br><span class="line">        &lt;id column=<span class="string">"sex"</span> jdbcType=<span class="string">"VARCHAR"</span> property=<span class="string">"sex"</span> /&gt;</span><br><span class="line">        &lt;id column=<span class="string">"status"</span> jdbcType=<span class="string">"VARCHAR"</span> property=<span class="string">"status"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">    &lt;sql id=<span class="string">"Base_Column_List"</span>&gt;</span><br><span class="line">              id,</span><br><span class="line">      user_name, sex, status</span><br><span class="line">  &lt;/sql&gt;</span><br></pre></td></tr></table></figure><h4 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dubbo连接zookeeper配置</span></span><br><span class="line"><span class="meta">dubbo.application.name</span>=<span class="string">MyDubbo_provider</span></span><br><span class="line"><span class="meta">dubbo.registry.protocol</span>=<span class="string">zookeeper</span></span><br><span class="line"><span class="meta">dubbo.registry.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="comment"># dubbo服务注册配置</span></span><br><span class="line"><span class="meta">dubbo.protocol.name</span>=<span class="string">dubbo</span></span><br><span class="line"><span class="meta">dubbo.protocol.port</span>=<span class="string">20880</span></span><br><span class="line"><span class="comment"># 这个是扫描服务的实现类</span></span><br><span class="line"><span class="meta">dubbo.scan.base-packages</span>=<span class="string">com.archiver.provider.**.service</span></span><br><span class="line"></span><br><span class="line"><span class="meta">package.base</span>=<span class="string">com.archiver.service</span></span><br><span class="line"><span class="comment">#mybatis-plus配置</span></span><br><span class="line"><span class="meta">mybatis-plus.configuration.log-impl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line"><span class="meta">mybatis-plus.type-aliases-package</span>=<span class="string">$&#123;package.base&#125;.entity</span></span><br><span class="line"><span class="meta">mybatis-plus.mapper-locations</span>=<span class="string">classpath:mapper/**/*Mapper.xml</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#druid 连接池配置</span></span><br><span class="line"><span class="meta">spring.datasource.druid.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3307/byte_easy?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=CTT</span></span><br><span class="line"><span class="meta">spring.datasource.druid.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.druid.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="meta">spring.datasource.druid.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.druid.initial-size</span>=<span class="string">5</span></span><br><span class="line"><span class="meta">spring.datasource.druid.max-active</span>=<span class="string">30 </span></span><br><span class="line"><span class="meta">spring.datasource.druid.min-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="meta">spring.datasource.druid.max-wait</span>=<span class="string">60000</span></span><br><span class="line"><span class="meta">spring.datasource.druid.time-between-eviction-runs-millis</span>=<span class="string">60000</span></span><br><span class="line"><span class="meta">spring.datasource.druid.min-evictable-idle-time-millis</span>=<span class="string">300000</span></span><br><span class="line"><span class="meta">spring.datasource.druid.validation-query</span>=<span class="string">SELECT 1 FROM DUAL</span></span><br><span class="line"><span class="meta">spring.datasource.druid.test-while-idle</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.datasource.druid.test-on-borrow</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">spring.datasource.druid.test-on-return</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">spring.datasource.druid.pool-prepared-statements</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.datasource.druid.max-pool-prepared-statement-per-connection-size</span>=<span class="string">50</span></span><br><span class="line"><span class="meta">spring.datasource.druid.filters</span>=<span class="string">stat,wall</span></span><br><span class="line"><span class="meta">spring.datasource.druid.connection-properties</span>=<span class="string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span></span><br><span class="line"><span class="meta">spring.datasource.druid.use-global-data-source-stat</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.datasource.druid.stat-view-servlet.login-username</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.datasource.druid.stat-view-servlet.login-password</span>=<span class="string">123456</span></span><br><span class="line"><span class="meta">spring.datasource.druid.web-stat-filter.exclusions</span>=<span class="string">*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*</span></span><br></pre></td></tr></table></figure><h3 id="第五步：编写-consumer"><a href="#第五步：编写-consumer" class="headerlink" title="第五步：编写 consumer"></a>第五步：编写 consumer</h3><p>消费者就相当于一个 controller，来与前台进行交互</p><p><img alt="image-20200306103404021" data-src="https://cdn.kaiming66.com/%E5%88%86%E5%B8%83%E5%BC%8F-image-20200306103404021.png" class="lazyload"></p><h4 id="Pom-文件-1"><a href="#Pom-文件-1" class="headerlink" title="Pom 文件"></a>Pom 文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.archiver.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="RestController"><a href="#RestController" class="headerlink" title="RestController"></a>RestController</h4><ul><li>这里也要注意 @Reference 注解，我们平常是 @AutoWired 注解，这里要使用 dubbo 的注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"rest/student"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestStudentController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> IStudentService studentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AjaxResult <span class="title">index</span><span class="params">(Student student)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        studentService.index(student);</span><br><span class="line">        <span class="keyword">return</span> AjaxResult.success();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="application-properties-1"><a href="#application-properties-1" class="headerlink" title="application.properties"></a>application.properties</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8085</span></span><br><span class="line"><span class="comment">#dubbo配置</span></span><br><span class="line"><span class="meta">dubbo.application.name</span>=<span class="string">MyDubbo_consumer</span></span><br><span class="line"><span class="meta">dubbo.registry.protocol</span>=<span class="string">zookeeper</span></span><br><span class="line"><span class="meta">dubbo.registry.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br></pre></td></tr></table></figure><h3 id="第六步：下载-zk-ui"><a href="#第六步：下载-zk-ui" class="headerlink" title="第六步：下载 zk-ui"></a>第六步：下载 zk-ui</h3><p>&emsp;&emsp;OK 至此我们完成了基础项目的搭建，为了能更好的直观的看到 zk 中的服务，来管理 zk，我们还需要一个可视化的 zk 管理界面工具，这里用的是 zk-ui。<a href="https://github.com/DeemOpen/zkui" target="_blank" rel="noopener">项目连接</a></p><p>&emsp;&emsp;这个下载下来直接启动就好，端口号是 9090，账号：admin，密码：manager</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li>访问消费者 controller</li></ul><p><img alt="image-20200306122541420" data-src="https://cdn.kaiming66.com/%E5%88%86%E5%B8%83%E5%BC%8F-image-20200306122541420.png" class="lazyload"></p><ul><li>登录 zk-ui</li></ul><p><img alt="image-20200306122615455" data-src="https://cdn.kaiming66.com/%E5%88%86%E5%B8%83%E5%BC%8F-image-20200306122615455.png" class="lazyload"></p><p>这样就注册到了 zk 中，接下来也访问成功，那么整个基础框架就搭好了。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java--对象的初始化流程</title>
      <link href="/2020/02/27/Java/Java--%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/"/>
      <url>/2020/02/27/Java/Java--%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Java–对象的初始化流程"><a href="#Java–对象的初始化流程" class="headerlink" title="Java–对象的初始化流程"></a>Java–对象的初始化流程</h1><p>先说结论：</p><ul><li>无继承的情况下初始化顺序：（静态代码块、静态变量）&gt;（普通代码块、普通变量）&gt;（构造函数）</li><li>括号里的是按代码顺序执行</li><li>有继承的情况下（别人博客里的一张图，侵删）：</li></ul><p><img alt="image-20200302133814693" data-src="https://cdn.kaiming66.com/Java-image-20200302133814693.png" class="lazyload"></p><p>总的来说都是静态代码先于普通代码然后最后是构造函数这个顺序</p><p><strong>重点：static 修饰的变量或者代码块只加载一次</strong></p><ul><li>看看代码加深理解：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InitializeTest t1 = <span class="keyword">new</span> InitializeTest(<span class="string">"t1"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InitializeTest t2 = <span class="keyword">new</span> InitializeTest(<span class="string">"t2"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = print(<span class="string">"i"</span>);</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        print(<span class="string">"静态构造块"</span>);</span><br><span class="line">        n=<span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> n = <span class="number">99</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="string">"构造块"</span>);</span><br><span class="line">        j = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = print(<span class="string">"j"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">print</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        System.out.println((k++) + <span class="string">" :"</span> + str + <span class="string">"   i="</span> + i + <span class="string">"   n="</span> + n);</span><br><span class="line">        ++n;</span><br><span class="line">        <span class="keyword">return</span> ++i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InitializeTest</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        System.out.println((k++) + <span class="string">" :"</span> + str + <span class="string">"   i="</span> + i + <span class="string">"   n="</span> + n);</span><br><span class="line">        ++i;</span><br><span class="line">        ++n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InitializeTest initializeTest = <span class="keyword">new</span> InitializeTest(<span class="string">"初始化"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> :构造块   i=<span class="number">0</span>   n=<span class="number">0</span></span><br><span class="line"><span class="number">2</span> :j   i=<span class="number">1</span>   n=<span class="number">1</span></span><br><span class="line"><span class="number">3</span> :t1   i=<span class="number">2</span>   n=<span class="number">2</span></span><br><span class="line"><span class="number">4</span> :构造块   i=<span class="number">3</span>   n=<span class="number">3</span></span><br><span class="line"><span class="number">5</span> :j   i=<span class="number">4</span>   n=<span class="number">4</span></span><br><span class="line"><span class="number">6</span> :t2   i=<span class="number">5</span>   n=<span class="number">5</span></span><br><span class="line"><span class="number">7</span> :i   i=<span class="number">6</span>   n=<span class="number">6</span></span><br><span class="line"><span class="number">8</span> :静态构造块   i=<span class="number">7</span>   n=<span class="number">7</span></span><br><span class="line"><span class="number">9</span> :构造块   i=<span class="number">8</span>   n=<span class="number">99</span></span><br><span class="line"><span class="number">10</span> :j   i=<span class="number">9</span>   n=<span class="number">100</span></span><br><span class="line"><span class="number">11</span> :初始化   i=<span class="number">10</span>   n=<span class="number">101</span></span><br></pre></td></tr></table></figure><ul><li>简单梳理下流程，我们要初始化这个类，然后按从上到下顺序执行代码：<ul><li>首先是类变量 k 初始化为 1</li><li>然后是一个静态类自己本身，而静态代码只执行一次，所以这次他只初始化普通代码块所以第一行结果为构造块</li><li>这时用到类变量 i ，我们调用 print 方法</li><li>然后该构造函数 t1</li><li>t2 同理</li><li>t2 初始化完后继续按代码流程走该类变量 i</li><li>静态代码块，它里面的给 n 赋值其实被下面的初始化所覆盖了所以相当于没用</li><li>按顺序执行到初始化完成。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java--深入理解SPI机制</title>
      <link href="/2020/02/23/Java/Java--%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SPI%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/02/23/Java/Java--%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SPI%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Java–深入理解SPI机制"><a href="#Java–深入理解SPI机制" class="headerlink" title="Java–深入理解SPI机制"></a>Java–深入理解SPI机制</h1><blockquote><p>总结于<a href="http://blog.itpub.net/69912579/viewspace-2656555/" target="_blank" rel="noopener">《深入理解 Java 中 SPI 机制》</a>、<a href="https://www.jianshu.com/p/3a3edbcd8f24" target="_blank" rel="noopener">《深入理解SPI机制》</a></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;<strong>SPI（Service Provider Interface）</strong>，是 JDK 内置的一种 <strong>服务发现机制</strong>，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，比如 java.sql.Driver 接口，其他不同厂商可以针对同一接口做出不同的实现，MySQL 和PostgreSQL 都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。Java中 SPI 机制主要思想是将装配的控制权移到程序之外（有点 IOC 内味了），在模块化设计中这个机制尤其重要，其核心思想就是 <strong>解耦</strong>。</p><p><img alt="1568077097364725" data-src="https://cdn.kaiming66.com/Java-1568077097364725.jpg" class="lazyload"></p><p>SPI与API区别：</p><ul><li>API是调用并用于实现目标的类、接口、方法等的描述；</li><li>SPI是扩展和实现以实现目标的类、接口、方法等的描述；</li></ul><p>换句话说，API 为操作提供特定的类、方法，SPI 通过操作来符合特定的类、方法。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>&emsp;&emsp;首先我们通过一个小例子，能更好的理解 SPI 机制：</p><ul><li>首先我们自定义一个接口，SPIService</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SPIService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">excute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后我们写两个实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpiImpl1</span> <span class="keyword">implements</span> <span class="title">SPIService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">excute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SpiImpl1.excute()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只是单纯的两个实现类，之间做一下区分</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpiImpl2</span> <span class="keyword">implements</span> <span class="title">SPIService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">excute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SpiImpl2.excute()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后要在 classpath 路径下配置添加一个文件，文件名是 SPIService 接口的全限定名，内容是实现了这个接口的类的全限定名，多个实现类之间用回车隔开。</li></ul><p><img alt="image-20200301154217277" data-src="https://cdn.kaiming66.com/Java-image-20200301154217277.png" class="lazyload"></p><p>文件里的内容：</p><p><img alt="image-20200301154308588" data-src="https://cdn.kaiming66.com/Java-image-20200301154308588.png" class="lazyload"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>&emsp;&emsp;然后我们用 SPI 提供的类 <code>ServiceLoader.load</code>或者<code>Service.providers</code>方法来拿到他们的实现类的实例。其中，<code>Service.providers</code>包位于<code>sun.misc.Service</code>，而<code>ServiceLoader.load</code>包位于<code>java.util.ServiceLoader</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Iterator&lt;SPIService&gt; providers = Service.providers(SPIService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        ServiceLoader&lt;SPIService&gt; loader = ServiceLoader.load(SPIService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">//两种不同的方式拿到实现类的实例</span></span><br><span class="line">        <span class="keyword">while</span> (providers.hasNext())&#123;</span><br><span class="line">            SPIService spi = providers.next();</span><br><span class="line">            spi.excute();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"----------------------------------"</span>);</span><br><span class="line">        Iterator&lt;SPIService&gt; iterator = loader.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            SPIService spi = iterator.next();</span><br><span class="line">            spi.excute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SpiImpl1.excute()</span><br><span class="line">SpiImpl2.excute()</span><br><span class="line">----------------------------------</span><br><span class="line">SpiImpl1.excute()</span><br><span class="line">SpiImpl2.excute()</span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><ul><li>我们可以看到，这里规定了默认的配置文件路径 <code>META-INF/services</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServiceLoader实现了Iterable接口，可以遍历所有的服务实现者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLoader</span>&lt;<span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">S</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 查找配置文件的目录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">"META-INF/services/"</span>;</span><br><span class="line">    <span class="comment">// 表示要被加载的服务的类或接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;S&gt; service;</span><br><span class="line">    <span class="comment">// 这个ClassLoader用来定位，加载，实例化服务提供者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader loader;</span><br><span class="line">    <span class="comment">// 访问控制上下文</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line">    <span class="comment">// 缓存已经被实例化的服务提供者，按照实例化的顺序存储</span></span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="keyword">private</span> LazyIterator lookupIterator; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>核心功能的实现即查找实现类和创建类实例的过程都是由 <code>LazyIterator</code> 实现的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务提供者查找的迭代器</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 服务提供者接口</span></span><br><span class="line">    Class&lt;S&gt; service;</span><br><span class="line">    <span class="comment">// 类加载器</span></span><br><span class="line">    ClassLoader loader;</span><br><span class="line">    <span class="comment">// 保存实现类的url</span></span><br><span class="line">    Enumeration&lt;URL&gt; configs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 保存实现类的全名</span></span><br><span class="line">    Iterator&lt;String&gt; pending = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 迭代器中下一个实现类的全名</span></span><br><span class="line">    String nextName = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String fullName = PREFIX + service.getName();</span><br><span class="line">                <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">                    configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    configs = loader.getResources(fullName);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">                fail(service, <span class="string">"Error locating configuration files"</span>, x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pending = parse(service, configs.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">        nextName = pending.next();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasNext()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历迭代器中的类挨个实例化</span></span><br><span class="line">        String cn = nextName;</span><br><span class="line">        nextName = <span class="keyword">null</span>;</span><br><span class="line">        Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过反射创建实现类的实例</span></span><br><span class="line">            c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">            fail(service,<span class="string">"Provider "</span> + cn + <span class="string">" not found"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">            fail(service, <span class="string">"Provider "</span> + cn  + <span class="string">" not a subtype"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            S p = service.cast(c.newInstance());</span><br><span class="line">            providers.put(cn, p);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">            fail(service, <span class="string">"Provider "</span> + cn + <span class="string">" could not be instantiated: "</span> + x, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error();          <span class="comment">// This cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，**ServiceLoader实现了Iterable接口，所以它有迭代器的属性，这里主要都是实现了迭代器的hasNext和next方法。这里主要都是调用的lookupIterator的相应hasNext和next方法，lookupIterator是懒加载迭代器。</p><p><strong>其次，</strong>LazyIterator中的hasNext方法，静态变量PREFIX就是”META-INF/services/”目录，这也就是为什么需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件。</p><p><strong>最后，</strong>通过反射方法Class.forName()加载类对象，并用newInstance方法将类实例化，并把实例化后的类缓存到providers对象中，(LinkedHashMap&lt;String,S&gt;类型） 然后返回实例对象。</p><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><ol><li><p>不能按需加载，需要遍历所有的实现，并实例化，然后在循环中才能找到我们需要的实现。如果不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。</p></li><li><p>获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。</p></li><li><p>多个并发多线程使用 ServiceLoader 类的实例是不安全的。</p></li></ol><p>以上不足可以参考 dubbo 实现的 SPI 机制，但是我还没学</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;通过 SPI 服务发现机制，我们就可以实现很多复杂的场景，比如 JDBC 的场景，由 Java 提供数据库连接规定的接口然后由第三方去实现，不同的厂商有不同的实现规范。在 JDBC 的 jar 包中就有 <code>META-IFN\services</code>下的一个 java.sql.Driver 文件，里面的内容就是 com.mysql.cj.jdbc.Driver ，这个类就是关于数据库连接的具体实现。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> SPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP--三次握手四次挥手</title>
      <link href="/2020/02/17/http/TCP--%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>/2020/02/17/http/TCP--%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP–三次握手四次挥手"><a href="#TCP–三次握手四次挥手" class="headerlink" title="TCP–三次握手四次挥手"></a>TCP–三次握手四次挥手</h1><blockquote><p>转载于 <a href="https://blog.csdn.net/qq_38950316/article/details/81087809" target="_blank" rel="noopener">TCP的三次握手与四次挥手理解及面试题（很全面）</a></p></blockquote><p>首先先来看看 TCP 的首部</p><p><img alt="20180717201939345" data-src="https://cdn.kaiming66.com/tcp-20180717201939345.jpg" class="lazyload"></p><ul><li>序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。</li><li>确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。</li><li>确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效</li><li>同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。</li><li>终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</li><li>PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。</li></ul><p><img alt="image-20200220140010593" data-src="https://cdn.kaiming66.com/tcp-image-20200220140010593.png" class="lazyload"></p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><img alt="20180717202520531" data-src="https://cdn.kaiming66.com/tcp-20180717202520531.png" class="lazyload"></p><ol><li>第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入<strong>SYN_SENT</strong>状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</li><li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入<strong>SYN_RECV</strong>状态；</li><li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入<strong>ESTABLISHED</strong>（TCP连接成功）状态，完成三次握手。</li></ol><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img alt="20180717204202563" data-src="https://cdn.kaiming66.com/tcp-20180717204202563.png" class="lazyload"></p><ol><li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li><li>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li><li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li><li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li><li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li><li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li></ol><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><p>【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？</p><p>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><p>【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</p><p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p><p>【问题3】为什么不能用两次握手进行连接？</p><p>答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。</p><p>现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p><p>【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？</p><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP--断点续传和多线程下载</title>
      <link href="/2020/02/16/Java/HTTP--%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD/"/>
      <url>/2020/02/16/Java/HTTP--%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP–断点续传和多线程下载"><a href="#HTTP–断点续传和多线程下载" class="headerlink" title="HTTP–断点续传和多线程下载"></a>HTTP–断点续传和多线程下载</h1><blockquote><p>总结与<a href="https://www.iteye.com/blog/uule-2429222" target="_blank" rel="noopener">《HTTP-断点续传和多线程下载》</a>和《图解HTTP》</p></blockquote><p>&emsp;&emsp;HTTP 的断点续传依赖于首部的两个字段 ：Range 和 Content-range</p><ul><li>Range：客户端发请求的范文（闭区间）</li><li>Content-range：服务端返回当前请求范围和文件总大小</li></ul><p>HTTP 1.1 协议开始支持文件的部分传输，续传成功返回 206。</p><h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><ul><li><p>用于请求头，请求内容的第一个字节和最后一个字节的位置，一般格式：</p></li><li><p>Range:(unit=first byte pos)-[last byte pos]</p></li></ul><p><strong>注意事项</strong>：</p><ol><li>这个数据区间是闭合的区间，起始值是 0，bytes = 0-1，指的是 0 和 1 两个字节的内容。</li><li>Range ：bytes = -200，前面这里加了个负号，表示的是结尾处的 200 字节文件</li><li>如果后面那个数小于前面那个数，即结束范围小于起始范围这是不合理的，即这个 Range 请求时无效的，服务器会无视该 Range 请求，而返回一个 200 ，把整个文件发给客户端。</li><li>如果后面那个数大于文件的长度，那么这个 Range 请求时不能被满足的，server 会回应一个 416：Requested range not satisfiable</li></ol><p><strong>示例解释：</strong></p><p>Range: bytes=0-499  表示第 0-499 字节范围的内容 </p><p>Range: bytes=500-999 表示第 500-999 字节范围的内容 </p><p>Range: bytes=-500  表示最后 500 字节的内容 </p><p><strong>Range: bytes=500-  表示从第 500 字节开始到文件结束部分的内容</strong> </p><p>Range: bytes=0-0,-1 表示第一个和最后一个字节 </p><p>Range: bytes=500-600,601-999 同时指定几个范围</p><h2 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h2><ul><li>用于响应头中，在发出带 Range 的请求后，服务器会在 Content-Range 头部**返回当前接受的范围和文件总大小，中间用斜杠隔开，一般格式：</li><li>Content-Range: bytes (unit first byte pos) - [last byte pos]/<strong>[entity legth]</strong></li></ul><p>例如：</p><p>请求下载整个文件: </p><p>GET /test.rar HTTP/1.1 </p><p>Connection: close </p><p>Host: 116.1.219.219 </p><p><strong>Range: bytes=0-801  //一般请求下载整个文件是bytes=0- 或不用这个头</strong></p><p>一般正常回应 </p><p>HTTP/1.1 200 OK </p><p>Content-Length: 801   </p><p>Content-Type: application/octet-stream </p><p><strong>Content-Range: bytes 0-800/801  //801:文件总大小</strong></p><p>而在响应完成后，返回的响应头内容也不同：</p><p><strong>HTTP/1.1 200 Ok（不使用断点续传方式）</strong></p><p><strong>HTTP/1.1 206 Partial Content（使用断点续传方式）</strong></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>HTTP1.1协议（RFC2616）中定义了断点续传相关的HTTP头 Range和Content-Range字段，一个最简单的断点续传实现大概如下： </p><ol><li>客户端下载一个1024K的文件，已经下载了其中512K  </li><li>网络中断，客户端请求续传，因此需要在HTTP头中申明本次需要续传的片段：<br>Range:bytes=512000-<br>这个头通知服务端从文件的512K位置开始传输文件 </li><li><strong>服务端收到断点续传请求，从文件的512K位置开始传输</strong>，并且在HTTP头中增加：<br>Content-Range: bytes 512000-/1024000<br>并且<strong>此时服务端返回的HTTP状态码应该是206，而不是200。</strong> </li></ol><h3 id="可能的问题"><a href="#可能的问题" class="headerlink" title="可能的问题"></a>可能的问题</h3><p>&emsp;&emsp;在终端发起续传请求时，URL对应的文件内容在服务端已经发生变化，此时续传的数据肯定是错误的。如何解决这个问题了？</p><p>&emsp;&emsp;响应的首部字段中还有一个字段是 ETag 字段，它能告知客户端实体的标识，它是一种可将资源以字符串形式做唯一标识的方式。服务器会对每一个资源分配对应的 ETag 值。当资源更新时，ETag 值也会随之更新，生成 ETag 并没有固定的法则，都是由服务器决定比如：md5 </p><p>&emsp;&emsp;而客户端的请求头中也有一个首部字段是 if-Range ，If-Range中的内容可以为最初收到的ETag头或者是Last-Modfied中的最后修改时候。<strong>服务端在收到续传请求时</strong>，通过If-Range中的内容进行校验，<strong>校验一致时返回206的续传回应，不一致时服务端则返回200回应，回应的内容为新的文件的全部数据。</strong></p><h2 id="多线程下载"><a href="#多线程下载" class="headerlink" title="多线程下载"></a>多线程下载</h2><p>&emsp;&emsp;假设你<strong>要开发一个多线程下载工具，你会自然的想到把文件分割成多个部分，比如4个部分，然后创建4个线程，每个线程负责下载一个部分</strong>，<strong>如果文件大小为403个byte，那么你的分割方式可以为：0-99 (前100个字节)，100-199(第二个100字节)，200-299(第三个100字节)，300-402（最后103个字节）。</strong></p><p>&emsp;&emsp;分割完成，每个线程都明白自己的任务，比如线程3的任务是负责下载200-299这部分文件，现在的问题是：线程3发送一个什么样的请求报文，才能够保证只请求文件的200-299字节，而不会干扰其他线程的任务。这时，我们可以使用HTTP1.1的Range头。Range头域可以请求实体的一个或者多个子范围，Range的值为0表示第一个字节，也就是Range计算字节数是从0开始的。</p>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP--你需要知道的小知识</title>
      <link href="/2020/02/16/http/HTTP--%E7%BB%86%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2020/02/16/http/HTTP--%E7%BB%86%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP–你需要知道的小知识"><a href="#HTTP–你需要知道的小知识" class="headerlink" title="HTTP–你需要知道的小知识"></a>HTTP–你需要知道的小知识</h1><blockquote><p>总结与《图解HTTP》&amp; <a href="https://developer.51cto.com/art/201910/604255.htm" target="_blank" rel="noopener">详解HTTP2四大核心特性</a></p></blockquote><h2 id="URI-和-URL-的区别"><a href="#URI-和-URL-的区别" class="headerlink" title="URI 和 URL 的区别"></a>URI 和 URL 的区别</h2><ul><li>URI 是用字符串标识某一互联网的资源</li><li>URL 是表示资源的地点（互联网上所处的位置）</li><li>URI 包括 URL，URL 是 URI 的子集</li></ul><h2 id="HTTP-1-1-默认持久链接（即长链接）"><a href="#HTTP-1-1-默认持久链接（即长链接）" class="headerlink" title="HTTP 1.1 默认持久链接（即长链接）"></a>HTTP 1.1 默认持久链接（即长链接）</h2><ul><li>长链接：<ul><li>http 在传输操作频繁，频繁请求资源的情况下为了减少 TCP 不断建立连接的消耗适用于长链接</li><li>缺点是链接数不能过多，服务器每多一个请求就要去维护一个链接当链接数特别多时，服务器的负载会越来越重</li></ul></li><li>短连接：<ul><li>在并发量大，用户操作不频繁时用短链接好否则维护链接是笔巨大的开销</li></ul></li></ul><h2 id="一台虚拟机主机可以存在多个域名"><a href="#一台虚拟机主机可以存在多个域名" class="headerlink" title="一台虚拟机主机可以存在多个域名"></a>一台虚拟机主机可以存在多个域名</h2><ul><li>即一个 ip 地址对应多个域名，这个可以通过 request header 中的 host 首部字段来区分要响应哪一个对应的页面</li></ul><h2 id="代理和网关的区别"><a href="#代理和网关的区别" class="headerlink" title="代理和网关的区别"></a>代理和网关的区别</h2><ul><li>网关和代理的机制十分相似，而网关能使通信新路上的 服务器提供非 HTTP 协议服务，利用网关也可以提高通信的安全性，因为可以在客户端与网关之间的通信线路上进行加密确保安全</li></ul><h2 id="首部字段"><a href="#首部字段" class="headerlink" title="首部字段"></a>首部字段</h2><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><ul><li>no-cache：的意思并不是不缓存，而是不缓存过期的资源</li><li>no-store：这个是真正的不缓存</li><li>max-age：资源作为缓存的最长时间</li><li>min-fresh：比如设定 60，则在这60s内超过期限的缓存都不能返回响应</li><li>max-stale：接受过期缓存</li></ul><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><ul><li>控制代理不再转发首部字段</li><li>管理持久链接</li></ul><h3 id="Expires-amp-max-age"><a href="#Expires-amp-max-age" class="headerlink" title="Expires &amp; max-age"></a>Expires &amp; max-age</h3><ul><li>Expires 绝对过期时间（http 1.0）</li><li>max-age 相对过期时间 （http 1.1）</li></ul><h3 id="DNT"><a href="#DNT" class="headerlink" title="DNT"></a>DNT</h3><p>DNT（Do Not Track）意思是拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法</p><ul><li>0：同意被追踪</li><li>1：不同意被追踪</li></ul><h2 id="HTTP-是无状态协议"><a href="#HTTP-是无状态协议" class="headerlink" title="HTTP 是无状态协议"></a>HTTP 是无状态协议</h2><ul><li>也就是说这个协议本身不会记录任何请求和响应的信息，就算是同一个客户端刚发完请求，它又发来一个请求时，服务器端也根本不认识，两个请求之间没有任何联系。</li><li>因为无状态所以造成的 header 头部特别大</li><li>解决方法：cookie 客户端记录信息、session 服务端记录信息，缓存代理记录信息</li></ul><h2 id="HTTP-1-0-和-HTTP-1-1-的区别"><a href="#HTTP-1-0-和-HTTP-1-1-的区别" class="headerlink" title="HTTP 1.0 和 HTTP 1.1 的区别"></a>HTTP 1.0 和 HTTP 1.1 的区别</h2><ul><li>长短链接<ul><li>HTTP 1.0 默认采用短链接</li><li>HTTP 1.1 默认采用长链接，而且 HTTP 1.1 的长链接有非流水线方式和流水线方式<ul><li>流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。</li><li>与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li></ul></li></ul></li><li>缓存处理<ul><li>HTTP 1.0 主要使用 header 里的 If-Modified-Since,Expires 来作为缓存判断的标准</li><li>HTTP 1.1 引入了更多的缓存控制策略，max-age 来表示相对的存活时间</li></ul></li><li>带宽的优化<ul><li>HTTP 1.0 即使客户端只想要对象的一部分，服务器也只能将整个对象传过来，造成带宽的浪费</li><li>HTTP 1.1 加入了 Range 首部字段，用来允许传送对象的某个部分，支持断点续传</li></ul></li><li>新增了错误状态响应码</li></ul><h2 id="HTTP-2-的认识"><a href="#HTTP-2-的认识" class="headerlink" title="HTTP 2 的认识"></a>HTTP 2 的认识</h2><p>大家可以通过该<a href="https://http2.akamai.com/demo" target="_blank" rel="noopener">链接</a>来直观感受一下 http 和 http 2 速度的差异</p><p><img alt="img" data-src="https://cdn.kaiming66.com/http-c86ac19836120f6e7efcb4399f4f8dee.gif" class="lazyload"></p><ul><li><p>二进制流</p><ul><li>HTTP2采用的是二进制格式传输数据，而HTTP 1.1采用的是文本形式</li><li>二进制协议解析起来更高效，而且分割为更小的帧，采用二进制编码</li></ul></li><li><p>多路复用</p><ul><li>解决了 HTTP 1.x 的只能串行传输的问题，也就是说我长连接虽然只建立一次连接但是传输的过程还得一个一个的传。</li><li>而 HTTP 2 单个链接可以承载任意的双向数据流，并行的发送多个请求，性能得到极大的提升.</li></ul></li><li><p>头部压缩</p><ul><li>开发了专门的”HPACK”算法，建立了动态表和静态表，采用了哈夫曼编码来压缩整数和字符串</li></ul><p>例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。</p><p><img alt="img" data-src="https://cdn.kaiming66.com/http-3b9e1626cc3a1bc568827f5f82bf3b62.png" class="lazyload"></p></li><li><p>Server Push</p><ul><li>改变了传统的 “ 请求-应答 ” 模式，不再是单一的由客户端发起访问，而是服务器也可以向客户端推送消息</li><li>比如，在浏览器刚请求HTML的时候就提前把可能会用到的JS、CSS文件发给客户端，减少等待的延迟，这被称为”服务器推送”（ Server Push，也叫 Cache push）。</li></ul></li></ul><h2 id="HTTP-与-HTTPS-的区别"><a href="#HTTP-与-HTTPS-的区别" class="headerlink" title="HTTP 与 HTTPS 的区别"></a>HTTP 与 HTTPS 的区别</h2><h3 id="HTTP-加密-认证-完整性保护-HTTPS"><a href="#HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="HTTP + 加密 + 认证 + 完整性保护 = HTTPS"></a>HTTP + 加密 + 认证 + 完整性保护 = HTTPS</h3><ul><li>端口：<ul><li>http :80，https:443</li></ul></li><li>安全性和资源消耗<ul><li>HTTP 使用明文传输内容，即使你用 post 传输一样是不安全的</li><li>HTTP 不能验证通信方的身份，可能会遭遇伪装</li><li>HTTP 无法证明报文的完整性，有可能中间被篡改</li><li>HTTPS 更加消耗资源（加密解密）</li><li>HTTP + SSL/TLS = HTTPS ，在加密前，http 是直接运行在 tcp 上的，加密后 http 先和 SSL/TLS 打交道，然后 SSL/TLS 再和 tcp 打交道，SSL/TLS 本身也是独立的可以用在不同的协议上来进行加密</li><li>而 HTTPS 采用的是混合加密的方式：共享密钥（对称加密）和公共密钥（非对称加密）的方式混合加密。也就是说先用非对称加密的方式传输加密要用的密钥，然后再用密钥完成剩下数据的传输。</li></ul></li></ul><h3 id="HTTPS-加密流程"><a href="#HTTPS-加密流程" class="headerlink" title="HTTPS 加密流程"></a>HTTPS 加密流程</h3><ul><li>首先要知道数字证书这个东西，由数字证书认证机构颁布（值得信赖的第三方）。我们想要实现上面的认证和完整性保护就要用到证书这个东西</li><li>我们的浏览器都会内置一些第三方认证机构的公钥，而服务器会把自己的公钥登录认证机构进行认证，认证机构会用密钥进行数字签名并颁发公钥证书（数字签名+服务器公钥）。</li><li>客户端拿到公钥证书后会用认证机构的公钥去认证这个公钥证书的正确性，认证通过后双发即能确认通信的各方。</li><li>然后客户端发送数据用服务器的公钥加密，服务器再用自己的私钥解密，就完成了数据的完整加密的传输。</li></ul>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP--GET和POST的区别</title>
      <link href="/2020/02/15/http/HTTP--GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/02/15/http/HTTP--GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP–GET和POST的区别"><a href="#HTTP–GET和POST的区别" class="headerlink" title="HTTP–GET和POST的区别"></a>HTTP–GET和POST的区别</h1><blockquote><p>总结自《图解HTTP》&amp; <a href="https://www.zhihu.com/question/28586791" target="_blank" rel="noopener">GET 和 POST 到底有什么区别？</a></p></blockquote><p>在讨论这个问题之前正好复习一下，HTTP协议的相关问题。</p><p>来嘛，先复习一遍计网基础知识：</p><p>​    OSI 七层模型，自下而上：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p><p>​    TCP/IP 四层模型：数据链路层、网络层、传输层、应用层</p><p>常见的协议（基于 TCP \ IP 模型）：</p><ul><li>ARP、IP、ICMP 协议都是网络层</li><li>TCP、UDP 为传输层协议</li><li>HTTP、FTP、DNS 等都为应用层协议</li><li>链路层主要就是：网卡、网络适配器等硬件设施</li></ul><p>​      HTTP 协议即<code>超文本传输协议</code>，这个 “超” 字意思是它不止能传输文字，还可以传输文件、图片、音频等，用于客户端和服务端之间的通信。那么就必有一端是客户端一端是服务器端。</p><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>​        GET 多用于请求获取一个 html 页面/图片/css/js 等资源，是 “读取” 资源的，反复读取不会对访问的数据有副作用，也就是不会修改数据，这被称为 <code>幂等性</code>。</p><p>​        因为 GET 是读取，那么就可以对 GET 请求进行缓存，这个缓存可以做到浏览器上，也可以交给（缓存）代理服务器上（如 nginx ），或者做到 server 端。</p><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>​        在页面中的 &lt;form&gt; 标签会定义一个表单，那么这个表单可以由 submit 提交给服务器，这种 POST 请求对服务器往往是有副作用的，增加数据或者修改数据、删除数据，是不幂等的。</p><p>​        那么不幂等就意味着没有办法缓存，你不能上次下单成功了这次还想下单，服务器直接把缓存中的成功下单页面给你，这是不符合逻辑的。你不能把他储存为书签，点一下一个 POST 就下一个单。</p><p>​        GET和POST携带数据的格式也有区别。当浏览器发出一个GET请求时，就意味着要么是用户自己在浏览器的地址栏输入，要不就是点击了html里a标签的href中的url （这里的 URL 中的中文只是让用户体验更好而已，实际上都要经过 URL编码翻译为真正的 URL 才能发给服务器，而且这里的长度也有限制 2kb）。所以其实并不是GET只能用url，而是浏览器直接发出的GET只能由一个url触发。所以没办法，GET上要在url之外带一些参数就只能依靠url上附带querystring。但是HTTP协议本身并没有这个限制。</p><p>​        浏览器在POST一个表单时，url上也可以带参数，只要 &lt;form action=”url” &gt; 里的 url 带 querystring 就行。只不过表单里面的那些用 &lt;input&gt;  等标签经过用户操作产生的数据都在会在body里。</p><p>因此我们一般会<strong>泛泛的说</strong>“GET请求没有body，只有 url ，请求数据放在 url 的 querystring 中；POST请求的数据在body中“。但这种情况仅限于浏览器发请求的场景。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img alt="image" data-src="https://cdn.kaiming66.com/http-get%E4%B8%8Epost.png" class="lazyload"></p><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET编码类型application/x-www-form-url，POST编码类型encodedapplication/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET对数据长度有限制，当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。POST无限制。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。其实一样 http 明文传输</li><li>GET参数通过URL传递，POST放在Request body中。</li></ul><p>​        GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 GET和POST还有一个重大区别，简单的说：GET产生一个TCP数据包；POST产生两个TCP数据包。<br>​      对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java--序列化与反序列化</title>
      <link href="/2020/02/13/Java/Java--%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2020/02/13/Java/Java--%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Java–序列化与反序列化"><a href="#Java–序列化与反序列化" class="headerlink" title="Java–序列化与反序列化"></a>Java–序列化与反序列化</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>永久性保存对象，保存对象的字节序列到本地文件或者数据库中</li><li>通过序列化以字节流的形式使对象在网络中进行传递和接收</li><li>通过序列化在进程间传递对象</li></ol><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>&emsp;&emsp;我们在序列化的时候可以实现两个接口：Serializable、Externalizable（继承了前者）通过 ObjectInputStream、ObjectOutputStream 来发送对象或者读取对象。</p><p>&emsp;&emsp;我们可以保存在本地文件中、数据库（blob）、网络传输都可以用序列化来把Java对象变成字节序列传输保存对象。</p><p>首先来个简单的序列化例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    String file = <span class="string">"D:\\Git\\data\\IO操作\\ddd.txt"</span>;</span><br><span class="line">    <span class="comment">//这个注解是lombok提供的用来关闭流的，我加上了总感觉没自己关闭舒服 :)</span></span><br><span class="line">    <span class="meta">@Cleanup</span> ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">    Student student = <span class="keyword">new</span> Student(<span class="number">1</span>,<span class="string">"张三"</span>,<span class="number">20</span>,<span class="string">"男"</span>);</span><br><span class="line">    oos.writeObject(student);</span><br><span class="line">    oos.flush();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cleanup</span> ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">    Student stu = (Student)ois.readObject();</span><br><span class="line">    System.out.println(stu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个是序列化ID，一般常用默认为 1L 就行，也可以是对象生产的哈希码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">//transient不会序列化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> stu_id;  <span class="comment">//该元素不会进行 jvm 默认的序列化，但是也可以自己完成序列化</span></span><br><span class="line">    <span class="keyword">private</span> String stuName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stuAge;</span><br><span class="line">    <span class="keyword">private</span> String stuSex;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> stu_id, String stuName, <span class="keyword">int</span> stuAge, String stuSex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stu_id = stu_id;</span><br><span class="line">        <span class="keyword">this</span>.stuName = stuName;</span><br><span class="line">        <span class="keyword">this</span>.stuAge = stuAge;</span><br><span class="line">        <span class="keyword">this</span>.stuSex = stuSex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用transient修饰之后，就可以通过重写这两个方法来完成定制的序列化操作</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">        s.defaultWriteObject();<span class="comment">//执行 jvm 默认序列化的元素进行序列化操作</span></span><br><span class="line">        s.writeInt(stu_id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span> <span class="keyword">throws</span> java.io.IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        <span class="keyword">this</span>.stu_id=s.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student(stu_id=<span class="number">1</span>, stuName=张三, stuAge=<span class="number">20</span>, stuSex=男)</span><br></pre></td></tr></table></figure><h2 id="Serializable、Externalizable-的比较"><a href="#Serializable、Externalizable-的比较" class="headerlink" title="Serializable、Externalizable 的比较"></a>Serializable、Externalizable 的比较</h2><ol><li><p>Serializable 是标识接口</p></li><li><p>Serializable提供了两种方式进行对象的序列化</p><ol><li>采用默认序列化方式，将非transatient和非static的属性进行序列化</li><li>编写readObject和writeObject完成部分属性的序列化</li></ol><p>Externalizable 接口的序列化，需要重写writeExternal和readExternal方法，并且在方法中编写相关的逻辑完成序列化和反序列化。</p></li><li><p>Externalizable接口的实现方式一定要有默认的<strong>无参构造函数</strong>，Serializable接口实现，其采用<strong>反射机制</strong>完成内容恢复，没有一定要有无参构造函数的限制</p></li><li><p>采用Externalizable无需产生序列化ID（serialVersionUID）而Serializable接口则需要</p></li><li><p>相比较Serializable, Externalizable序列化、反序列更加快速，占用相比较小的内存</p></li></ol><p>在项目中，大部分的类还是推荐使用Serializable, 有些类可以使用Externalizable接口，如：</p><ul><li>完全控制序列的流程和逻辑</li><li>需要大量的序列化和反序列化操作，而你比较关注资源和性能~ 当然，这种情况下，我们一般还会考虑第三方序列化/反序列化工具，如protobuf等进行序列化和反序列化操作</li></ul><h2 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h2><ul><li>序列化部分属性</li></ul><p>&emsp;&emsp;当我们不想实现序列化某个属性时，可以通过 <code>transient</code>、重写 <code>writeObject</code>，<code>readObject</code>、使用<code>Externalizable</code>实现，这三种方式来实现属性的部分序列化。</p><ul><li><code>serialVersionUID</code>不一致</li></ul><p>&emsp;&emsp;其目的是序列化对象版本控制，如果发送方和接收方都有一个相同的对象类型都实现了序列化接口，但是他们的<code>serialVersionUID</code>不一致，这样就会导致反序列化失败。</p><ul><li>静态变量的序列化</li></ul><p>&emsp;&emsp;静态变量是不参与序列化过程的</p><ul><li>对象里的属性是另外一个对象</li></ul><p>&emsp;&emsp;在一个对象进行序列化时，如果属性有其他对象也会一并的进行序列化操作，但是要保证属性对象也实现了<code>Serializable</code>接口，否则使用时会报错</p><ul><li>无法访问引用对象的源代码</li></ul><p>&emsp;&emsp;也就是说我想序列化我却不能给里面的属性对象也加上<code>Serializable</code>接口，那么我们可以尝试继承该类，然后让它实现序列化接口，但是下面两种情况不能序列化，那么这时我们只能用<code>transient</code>来修饰这个对象了</p><ol><li>如果引用类被定义为final</li><li>如果引用类引用了另外一个非可序列化的对象</li></ol><ul><li>读写顺序一致</li></ul><p>&emsp;&emsp;需要牢记的，<code>ObjectInputStream</code>读取数据的顺序和<code>ObjectOutputStream</code>写入数据的顺序是一致的.</p><ul><li>继承对于序列化的影响</li></ul><p>&emsp;&emsp;我们分为两点考虑，一个是父类可以序列化一个是不可序列化</p><ol><li>父类可以序列化时，那么子类继承父类也是可以进行序列化的</li><li>父类不可以序列化时，当子类进行反序列化时所有继承于父类的实例变量值，都会通过调用非序列化构造函数来初始化，也就是说我们不能序列化父类的属性。</li></ol><ul><li>序列化机制的特殊规则</li></ul><p>&emsp;&emsp;Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用</p><h2 id="单例模式下的坑"><a href="#单例模式下的坑" class="headerlink" title="单例模式下的坑"></a>单例模式下的坑</h2><p>&emsp;&emsp;这部分单独拿出来说，拿双重检查锁模式来说</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现序列化接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Long serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    Singleton singleton = Singleton.getInstance();</span><br><span class="line"></span><br><span class="line">    String file = <span class="string">"D:\\Git\\data\\IO操作\\ddd.txt"</span>;</span><br><span class="line">    <span class="meta">@Cleanup</span> ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">    System.out.println(singleton);</span><br><span class="line">    oos.writeObject(singleton);</span><br><span class="line">    oos.flush();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cleanup</span> ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">    singleton = (Singleton)ois.readObject();</span><br><span class="line">    System.out.println(singleton);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.example.demo.SingletonDemo.Singleton@<span class="number">685f</span>4c2e</span><br><span class="line">com.example.demo.SingletonDemo.Singleton@<span class="number">6</span>aa8ceb6</span><br></pre></td></tr></table></figure><p>哦豁该怎么办，Java已经考虑好这种情况<code>readResolve</code>，接下来修改代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Long serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//加入 readResolve 方法，直接返回对象实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"read Resolve"</span>);</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次测试结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.example.demo.SingletonDemo.Singleton@<span class="number">685f</span>4c2e</span><br><span class="line">read Resolve</span><br><span class="line">com.example.demo.SingletonDemo.Singleton@<span class="number">685f</span>4c2e</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式--单例模式</title>
      <link href="/2020/02/12/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/02/12/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式–单例模式"><a href="#设计模式–单例模式" class="headerlink" title="设计模式–单例模式"></a>设计模式–单例模式</h1><blockquote><p>出处：<a href="https://www.jianshu.com/p/3bfd916f2bb2" target="_blank" rel="noopener">设计模式之单例模式</a></p></blockquote><p>所谓单例，就是整个程序有且仅有一个实例。该类负责创建自己的对象，同时确保只有一个对象被创建。在Java，一般常用在工具类的实现或创建对象需要消耗资源。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>类构造器私有</li><li>持有自己类型的属性</li><li>对外提供获取实例的静态方法</li></ul><h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><p>等到要用的时候再去初始化对象</p><p>线程不安全，延迟初始化，严格意义上不是不是单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><p>不管有没有先去初始化对象。</p><p>线程安全，比较常用，但容易产生垃圾，因为一开始就初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双重检测锁模式"><a href="#双重检测锁模式" class="headerlink" title="双重检测锁模式"></a><strong>双重检测锁模式</strong></h2><p>线程安全，延迟初始化。这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;  </span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重检查模式，进行了两次的判断，第一次是为了避免不要的实例，第二次是为了进行同步，避免多线程问题。由于<code>singleton=new Singleton()</code>对象的创建在JVM中可能会进行重排序，在多线程访问下存在风险，使用<code>volatile</code>修饰<code>signleton</code>实例变量有效，解决该问题。</p><blockquote><p>双重检查模式与加锁的懒汉模式并不相同，这里相对于加锁的懒汉模式要多了一次检测，第一次检测是为了避免不必要的上锁，而第二次检查就是加锁后的例行检查</p></blockquote><h2 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a><strong>静态内部类单例模式</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> Inner.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有第一次调用getInstance方法时，虚拟机才加载 Inner 并初始化instance ，只有一个线程可以获得对象的初始化锁，其他线程无法进行初始化，保证对象的唯一性。目前此方式是所有单例模式中最推荐的模式，但具体还是根据项目选择。</p><h2 id="枚举单例模式"><a href="#枚举单例模式" class="headerlink" title="枚举单例模式"></a><strong>枚举单例模式</strong></h2><p>他这里还提到了枚举的单例模式，并不常见，知道就好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认枚举实例的创建是线程安全的，并且在任何情况下都是单例。实际上</p><ul><li>枚举类隐藏了私有的构造器。</li><li>枚举类的域 是相应类型的一个实例对象<br>那么枚举类型日常用例是这样子的：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton  &#123;</span><br><span class="line">    INSTANCE </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//doSomething 该实例支持的行为</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//可以省略此方法，通过Singleton.INSTANCE进行操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton get <span class="title">Instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举单例模式在《Effective Java》中推荐的单例模式之一。但枚举实例在日常开发是很少使用的，就是很简单以导致可读性较差。<br> 在以上所有的单例模式中，推荐静态内部类单例模式。主要是非常直观，即保证线程安全又保证唯一性。<br> 众所周知，单例模式是创建型模式，都会新建一个实例。那么一个重要的问题就是反序列化。当实例被写入到文件到反序列化成实例时，我们需要重写<code>readResolve</code>方法，以让实例唯一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java集合中的Iterator</title>
      <link href="/2020/02/08/Java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84Iterator/"/>
      <url>/2020/02/08/Java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84Iterator/</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解Java集合中的Iterator"><a href="#深入理解Java集合中的Iterator" class="headerlink" title="深入理解Java集合中的Iterator"></a>深入理解Java集合中的Iterator</h1><blockquote><p>总结自掘金的一篇文章：<a href="https://juejin.im/post/5d553d356fb9a06b317b5bee" target="_blank" rel="noopener">深入理解Java集合中的Iterator</a></p></blockquote><p>首先上一段面试题代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">"1"</span>);</span><br><span class="line">        list.add(<span class="string">"3"</span>);</span><br><span class="line">        list.add(<span class="string">"4"</span>);</span><br><span class="line">        list.add(<span class="string">"5"</span>);</span><br><span class="line">        list.add(<span class="string">"6"</span>);</span><br><span class="line">        list.add(<span class="string">"7"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"6"</span>.equals(o))</span><br><span class="line">                list.remove(o);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>问：这段代码会不会报错呢？</p><p>这段代码看起来挺平常的，我是没看出来啥问题（还是菜）。    </p><p>但是我们首先要知道的点：</p><ul><li>foreach 遍历底层是用迭代器来实现的</li><li>如果用迭代器遍历集合元素时，如果要删除或修改集合中元素，就必须使用迭代器的方法，不能用集合自身的方法</li></ul><p><img alt="image-20200208124552431" data-src="https://cdn.kaiming66.com/iterator-image-20200208124552431.png" class="lazyload"></p><p>所以根据上面的知识点，这段代码应该是会报错的，但是一运行：</p><p><img alt="image-20200208123029032" data-src="https://cdn.kaiming66.com/iterator-image-20200208123029032.png" class="lazyload"></p><p>没一点毛病，换个数试试？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">"1"</span>);</span><br><span class="line">        list.add(<span class="string">"3"</span>);</span><br><span class="line">        list.add(<span class="string">"4"</span>);</span><br><span class="line">        list.add(<span class="string">"5"</span>);</span><br><span class="line">        list.add(<span class="string">"6"</span>);</span><br><span class="line">        list.add(<span class="string">"7"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"3"</span>.equals(o)) <span class="comment">//仅仅修改了 equals前面的值 6 -&gt; 3</span></span><br><span class="line">                list.remove(o);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再次运行：</p><p><img alt="image-20200208123246605" data-src="https://cdn.kaiming66.com/iterator-image-20200208123246605.png" class="lazyload"></p><p>哦豁，就换了个数程序又报错了</p><p>既然是根据那篇文章总结，我们就直接了当的概况一下，总结一下大佬们的debug处理方式：</p><ul><li>根据现有知识寻找可能出错的点</li><li>当出现 bug 时，先从异常入手，分析这个异常是如何发生的（一看官方文档二看源码）</li><li>知道了异常的大概发生场景后，看控制台报错的行数，找到具体异常位置</li><li>接着就是一层层的往里深入，打断点不断调试，解决问题</li></ul><h2 id="涉及知识"><a href="#涉及知识" class="headerlink" title="涉及知识"></a>涉及知识</h2><h3 id="ConcurrentModificationException"><a href="#ConcurrentModificationException" class="headerlink" title="ConcurrentModificationException"></a>ConcurrentModificationException</h3><ul><li>这个异常会在一个对象被做了不合法的并发修改时抛出（单线程下也会出现）</li></ul><h3 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a>fail-fast</h3><ul><li>集合中通常会自带一个 fail-fast 的迭代器</li><li>所谓 fail-fast 就是检测到有异常越快抛出异常结束越好，避免了未知的隐患</li></ul><p><img alt="image-20200208125032417" data-src="https://cdn.kaiming66.com/iterator-image-20200208125032417.png" class="lazyload"></p><p>上图就是在 ArrayList 类中的迭代器，控制台的报错信息指向了里面 next 方法的 checkForComodification() 方法</p><p><img alt="image-20200208125412653" data-src="https://cdn.kaiming66.com/iterator-image-20200208125412653.png" class="lazyload"></p><p>这个方法也很简单，就是验证了 modeCount 和 expectedModCount 是否一致，不一致则异常</p><h3 id="modCount"><a href="#modCount" class="headerlink" title="modCount"></a>modCount</h3><ul><li>modCount是定义在AbstractList（ArrayList的父类）里面的一个属性。</li><li>这个字段用来记录 list 被结构性操作的次数，就是对 list 容量有影响或者迭代过程中会导致错误的操作。</li><li>如果想要实现 fail-fast 那就要在所有结构性操作的方法内部做 modCount++ 的操作</li><li>如果不想实现 fail-fast 就不需要，ArrayList 里的 add 方法就实现了 modCount++ 操作</li></ul><h3 id="expectedModCount"><a href="#expectedModCount" class="headerlink" title="expectedModCount"></a>expectedModCount</h3><ul><li>这个值在上面已经出现过了，在 ArrayList 的迭代器中会将 expectedModCount 的值初始化为 modCount 的值</li></ul><p><img alt="image-20200208135713681" data-src="https://cdn.kaiming66.com/iterator-image-20200208135713681.png" class="lazyload"></p><p>也就是说，在正常情况下，expectedModCount  和 modCount 的值是一致的，但是为什么会抛出不一致的异常呢？</p><p>打两个断点开始 debug :</p><p><img alt="image-20200208140304016" data-src="https://cdn.kaiming66.com/iterator-image-20200208140304016.png" class="lazyload"></p><p>因为刚开始 list 的 size 为 6 ，而 foreach 底层就是迭代器嘛，他会先判断 hasNext() ， cursor 是当前迭代器的游标，游标没有到 size 大小就会返回 true ，继续执行 next 方法，而 next 方法刚上来第一步就是检查一致性，因为我们初始化后没有再在结构性上动，所以一直保持一致，当我们迭代到 6 时，执行 remove 操作</p><p><img alt="image-20200208140904523" data-src="https://cdn.kaiming66.com/iterator-image-20200208140904523.png" class="lazyload"></p><p><img alt="image-20200208140920049" data-src="https://cdn.kaiming66.com/iterator-image-20200208140920049.png" class="lazyload"></p><p>上来就是修改 modCount++ ，所以这是 expectedModCount 为 6 ，而 modCount 为 7。迭代器继续迭代，cursor != size，进入 next 方法，上来检查就不一致所以报错。</p><h3 id="迭代器为什么不报错？"><a href="#迭代器为什么不报错？" class="headerlink" title="迭代器为什么不报错？"></a>迭代器为什么不报错？</h3><p><img alt="image-20200208141448037" data-src="https://cdn.kaiming66.com/iterator-image-20200208141448037.png" class="lazyload"></p><p>这说的很清楚了，就是迭代器会帮我们更新 expectModCount 的值，来使它与 modCount 保持一致，所以我们以后都要记得用迭代器的方法，才能保证不出错</p><p>至于上面为什么有时候报错，有时候就不报错，其实已经很简单了，跟着流程走一遍自然会发现。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>迭代器的 next 方法会检查一致性，而自己集合的结构性操作只 modCount++，而不更新 expectModCount，所以会报错。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Demo--静态代理模式</title>
      <link href="/2020/02/01/demo/Demo--%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/02/01/demo/Demo--%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Demo–静态代理模式"><a href="#Demo–静态代理模式" class="headerlink" title="Demo–静态代理模式"></a>Demo–静态代理模式</h1><ul><li>Person接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Actor类（实现 Person 接口）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Actor</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Actor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Actor</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Agent类（代理Actor类）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Agent</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Actor actor;</span><br><span class="line">    <span class="keyword">private</span> String before;</span><br><span class="line">    <span class="keyword">private</span> String after;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Agent</span><span class="params">(Actor actor, String before, String after)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.actor = actor;</span><br><span class="line">        <span class="keyword">this</span>.before = before;</span><br><span class="line">        <span class="keyword">this</span>.after = after;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Agent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before Actor,Agent say: "</span> + before);</span><br><span class="line">        actor.speak();</span><br><span class="line">        System.out.println(<span class="string">"Before Actor,Agent say: "</span> + after);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Test 测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StaticAgentTest</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Actor actor = <span class="keyword">new</span> Actor(<span class="string">"I am a Actor"</span>);</span><br><span class="line">    Agent agent = <span class="keyword">new</span> Agent(actor,<span class="string">"before"</span>,<span class="string">"after"</span>);</span><br><span class="line">    agent.speak();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before Actor,Agent say: before</span><br><span class="line">I am a Actor</span><br><span class="line">Before Actor,Agent say: after</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> demo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Demo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解spring--动手搭建IOC容器</title>
      <link href="/2020/01/31/Java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3spring--%E5%8A%A8%E6%89%8B%E6%90%AD%E5%BB%BAIOC%E5%AE%B9%E5%99%A8/"/>
      <url>/2020/01/31/Java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3spring--%E5%8A%A8%E6%89%8B%E6%90%AD%E5%BB%BAIOC%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解spring–手写简易的IOC容器"><a href="#深入理解spring–手写简易的IOC容器" class="headerlink" title="深入理解spring–手写简易的IOC容器"></a>深入理解spring–手写简易的IOC容器</h1><ul><li>使用过 spring 之后，发现很多东西都不用自己 new 很神奇，这些对象都是怎么来的呢？</li><li>IOC控制反转是怎么实现的呢？</li></ul><p>spring IOC 容器可以在对象生成或初始化的时候就把属性注入到对象中，如果对象 A 的一个属性为对象 B ，还可以将对象 B 的引用注入到对象 A 的数据域中。如果对象 A 在初始化的时候对象 B 还没有初始化，而 A 又需要 B 作为自己的属性，这时 IOC 容器就会递归的先实例化对象 B ，这样也可以把对象之间的依赖清晰的建立起来。</p><p>IOC容器把对象的创建工作从具体的业务对象手中抢过来，这样也达到了解耦的目的，开发更加方便。</p><p>项目 github 地址（建议加星，当然我只是建议）：<a href="https://github.com/Archivev/MyIOC" target="_blank" rel="noopener">https://github.com/Archivev/MyIOC</a></p><ul><li>简单的类结构图：</li></ul><p><img alt="image-20200201091027360" data-src="https://cdn.kaiming66.com/spring%E6%89%8B%E5%86%99IOC%E5%AE%B9%E5%99%A8image-20200201091027360.png" class="lazyload"></p><ul><li>这里 ApplicationContext 里并没有任何方法，只是模仿 spring 继承了 BeanFactory，真正的 spring 结构要更加复杂，这里只是梳理一下大致关系</li></ul><h2 id="容器要实现的功能"><a href="#容器要实现的功能" class="headerlink" title="容器要实现的功能"></a>容器要实现的功能</h2><ul><li>可以正确的解析xml文件，并将对象的实例创建出来</li><li>借助 BeanUtils 可以将属性值注入到对象实例中</li><li>可以设置 Scope 作用域为 singleton（单例模式）、prototype（多例模式）</li><li>可以实现对象类型的注入 ref</li></ul><h2 id="所需技术"><a href="#所需技术" class="headerlink" title="所需技术"></a>所需技术</h2><ul><li>dom4j 用来解析 xml 配置文件</li><li>BeanUtils 用来帮助我们对对象注入属性</li><li>Java反射机制</li></ul><h2 id="所需-jar-包："><a href="#所需-jar-包：" class="headerlink" title="所需 jar 包："></a>所需 jar 包：</h2><ul><li>BeanUtils工具类：<a href="https://cdn.kaiming66.com/jar-BeanUtils.zip" target="_blank" rel="noopener">BeanUtils</a></li><li>dom4j解析：<a href="https://cdn.kaiming66.com/jar-dom4j.zip" target="_blank" rel="noopener">dom4j</a></li></ul><h2 id="项目结构图及介绍："><a href="#项目结构图及介绍：" class="headerlink" title="项目结构图及介绍："></a>项目结构图及介绍：</h2><p><img alt="image-20200201093042996" data-src="https://cdn.kaiming66.com/spring%E6%89%8B%E5%86%99IOC%E5%AE%B9%E5%99%A8image-20200201093042996.png" class="lazyload"></p><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><h3 id="applicationContext-xml"><a href="#applicationContext-xml" class="headerlink" title="applicationContext.xml"></a>applicationContext.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"people"</span> <span class="attr">class</span>=<span class="string">"com.Archiver.entity.People"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"男"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.Archiver.entity.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"people"</span> <span class="attr">ref</span>=<span class="string">"people"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userId"</span> <span class="attr">value</span>=<span class="string">"11"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"man"</span> <span class="attr">class</span>=<span class="string">"com.Archiver.entity.Man"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"123"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"people"</span> <span class="attr">ref</span>=<span class="string">"people"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Bean-java"><a href="#Bean-java" class="headerlink" title="Bean.java"></a>Bean.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String scope=<span class="string">"singleton"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Property&gt; properties = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassName</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.className = className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getScope</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScope</span><span class="params">(String scope)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.scope = scope;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Property&gt; <span class="title">getProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(List&lt;Property&gt; properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Bean&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", className='"</span> + className + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", scope='"</span> + scope + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", properties="</span> + properties +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Property-java"><a href="#Property-java" class="headerlink" title="Property.java"></a>Property.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Property</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String ref;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRef</span><span class="params">(String ref)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ref = ref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Property&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", value='"</span> + value + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", ref='"</span> + ref + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Man-java"><a href="#Man-java" class="headerlink" title="Man.java"></a>Man.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> People people;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> People <span class="title">getPeople</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> people;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPeople</span><span class="params">(People people)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.people = people;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Man&#123;"</span> +</span><br><span class="line">                <span class="string">"people="</span> + people +</span><br><span class="line">                <span class="string">", age='"</span> + age + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="User-java"><a href="#User-java" class="headerlink" title="User.java"></a>User.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> People people;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserId</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> People <span class="title">getPeople</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> people;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPeople</span><span class="params">(People people)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.people = people;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"userId='"</span> + userId + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", people="</span> + people +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="People-java"><a href="#People-java" class="headerlink" title="People.java"></a>People.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"People&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", sex='"</span> + sex + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BeanFactory-java"><a href="#BeanFactory-java" class="headerlink" title="BeanFactory.java"></a>BeanFactory.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取容器中的bean实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是单例模式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是多例模式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 是否包含该bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ApplicationContext-java"><a href="#ApplicationContext-java" class="headerlink" title="ApplicationContext.java"></a>ApplicationContext.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ClassPathXmlApplicationContext-java"><a href="#ClassPathXmlApplicationContext-java" class="headerlink" title="ClassPathXmlApplicationContext.java"></a>ClassPathXmlApplicationContext.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">implements</span> <span class="title">ApplicationContext</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取解析到信息的map</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Bean&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//作为IOC容器使用，放置反射生成的对象</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; context = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String pathName)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读取配置文件得到初试化的Bean的信息</span></span><br><span class="line">        map = ParseXML.getConfig(pathName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过entrySet方法，返回一个储存map映射关系的set集合，分别取 key 和 value</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String,Bean&gt; e: map.entrySet()) &#123;</span><br><span class="line">            String beanName = e.getKey();</span><br><span class="line">            Bean bean = e.getValue();</span><br><span class="line"></span><br><span class="line">            Object exsitBean = context.get(beanName);</span><br><span class="line">            <span class="comment">//如果容器中没有而且作用域为单例时则创建对象</span></span><br><span class="line">            <span class="keyword">if</span> (exsitBean == <span class="keyword">null</span> &amp;&amp; <span class="string">"singleton"</span>.equals(bean.getScope()))&#123;</span><br><span class="line">                <span class="comment">//根据bean信息创建一个实例</span></span><br><span class="line">                exsitBean = createBean(bean);</span><br><span class="line">                <span class="comment">//并将实例放入容器中</span></span><br><span class="line">                context.put(beanName,exsitBean);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createBean</span><span class="params">(Bean bean)</span></span>&#123;</span><br><span class="line">        Class clazz = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            clazz = Class.forName(bean.getClassName());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ClassNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"没有找到该类"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Object object = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            object = clazz.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"没有提供无参构造器"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//BeanUtils注入属性的map</span></span><br><span class="line">        Map&lt;String,String&gt; pmap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Property p: bean.getProperties()) &#123;</span><br><span class="line">            String name = p.getName();</span><br><span class="line">            String value = p.getValue();</span><br><span class="line">            String ref = p.getRef();</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>)&#123;</span><br><span class="line">                pmap.put(name,value);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//利用Apache的BeanUtils注入属性</span></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    BeanUtils.populate(object,pmap);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"请检查你的"</span> + name + <span class="string">"属性"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ref != <span class="keyword">null</span>)&#123;</span><br><span class="line">                Object exsitBean = context.get(ref);</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 首先寻找容器中是否有 ref 的对象</span></span><br><span class="line"><span class="comment">                 * 如果有则不用再次创建，如果没有则递归的先 ref 的对象创建</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (exsitBean == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//从xml解析的map中取出bean并创建</span></span><br><span class="line">                    exsitBean = createBean(map.get(ref));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    BeanUtils.setProperty(object,name,exsitBean);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"您的bean的属性"</span> + name + <span class="string">"未设置set方法"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Object o = context.get(name);</span><br><span class="line">        <span class="comment">//如果为空则证明容器内没有，且为多例模式直接创建</span></span><br><span class="line">        <span class="comment">//也就是说单例模式下，初始化容器时直接创建，多例等到调用时在创建</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            o = createBean(map.get(name));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Bean bean = map.get(name);</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(bean.getScope(),<span class="string">"singleton"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Bean bean = map.get(name);</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(bean.getScope(),<span class="string">"prototype"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Object o = map.get(name);</span><br><span class="line">        <span class="keyword">if</span> (o != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ParseXML-java"><a href="#ParseXML-java" class="headerlink" title="ParseXML.java"></a>ParseXML.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseXML</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟IOC容器</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map&lt;String,Bean&gt;结构</span></span><br><span class="line"><span class="comment">     * String 用来模拟 bean 中的 id 值</span></span><br><span class="line"><span class="comment">     * Bean 模拟实际 IOC 容器中的 BeanDefinition</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Bean&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析xml配置文件中的bean并注入到容器中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pathName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Bean&gt; <span class="title">getConfig</span><span class="params">(String pathName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新建一个dom4j的解析器</span></span><br><span class="line">        SAXReader saxReader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        Document document = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//根据路径解析xml文件</span></span><br><span class="line">            document = saxReader.read(pathName);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"请检查您的xml配置文件是否正确"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据Xpath寻找bean节点</span></span><br><span class="line">        String Xpath = <span class="string">"//bean"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//寻找根节点下所有bean结构</span></span><br><span class="line">        List&lt;Element&gt; beans = document.selectNodes(Xpath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Element element: beans) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将解析到的内容封装到 bean 对象中</span></span><br><span class="line">            Bean bean = <span class="keyword">new</span> Bean();</span><br><span class="line">            String name = element.attributeValue(<span class="string">"id"</span>);</span><br><span class="line">            String className = element.attributeValue(<span class="string">"class"</span>);</span><br><span class="line">            String scope = element.attributeValue(<span class="string">"scope"</span>);</span><br><span class="line">            bean.setName(name);</span><br><span class="line">            bean.setClassName(className);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果没有写则默认单例</span></span><br><span class="line">            <span class="keyword">if</span> (scope!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                bean.setScope(scope);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//继续遍历bean节点下的property节点</span></span><br><span class="line">            List&lt;Element&gt; properties = element.elements(<span class="string">"property"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果有该节点则解析内容</span></span><br><span class="line">            <span class="keyword">if</span> (properties != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Element e:properties) &#123;</span><br><span class="line">                    Property property = <span class="keyword">new</span> Property();</span><br><span class="line">                    String pname = e.attributeValue(<span class="string">"name"</span>);</span><br><span class="line">                    String value = e.attributeValue(<span class="string">"value"</span>);</span><br><span class="line">                    String ref = e.attributeValue(<span class="string">"ref"</span>);</span><br><span class="line">                    property.setName(pname);</span><br><span class="line">                    property.setValue(value);</span><br><span class="line">                    property.setRef(ref);</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 获取list&lt;Property&gt;后向内添加元素</span></span><br><span class="line"><span class="comment">                     * 将解析到的属性封装到property中，并添加到bean中</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    bean.getProperties().add(property);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//封装到map中</span></span><br><span class="line">            map.put(name,bean);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Test-java"><a href="#Test-java" class="headerlink" title="Test.java"></a>Test.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ct = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"resources/applicationContext.xml"</span>);</span><br><span class="line">        People people = (People) ct.getBean(<span class="string">"people"</span>);</span><br><span class="line">        User user = (User) ct.getBean(<span class="string">"user"</span>);</span><br><span class="line">        Man man = (Man) ct.getBean(<span class="string">"man"</span>);</span><br><span class="line">        System.out.println(ct.containsBean(<span class="string">"man"</span>));</span><br><span class="line">        System.out.println(ct.getBean(<span class="string">"people"</span>));</span><br><span class="line">        System.out.println(ct.getBean(<span class="string">"people"</span>));</span><br><span class="line">        System.out.println(ct.isSingleton(<span class="string">"man"</span>));</span><br><span class="line">        System.out.println(ct.isPrototype(<span class="string">"man"</span>));</span><br><span class="line">        System.out.println(people);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        System.out.println(man);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何搭建spring源码的阅读环境</title>
      <link href="/2020/01/31/Java/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAspring%E6%BA%90%E7%A0%81%E7%9A%84%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83/"/>
      <url>/2020/01/31/Java/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAspring%E6%BA%90%E7%A0%81%E7%9A%84%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建spring源码阅读环境"><a href="#搭建spring源码阅读环境" class="headerlink" title="搭建spring源码阅读环境"></a>搭建spring源码阅读环境</h1><ul><li>面试一问你是否阅读过源码，你还不知道该如何去看spring源码？这里教你如何搭建一个spring源码的阅读环境。</li></ul><h2 id="所需环境"><a href="#所需环境" class="headerlink" title="所需环境"></a>所需环境</h2><ul><li>Gradle环境</li><li>IDEA或者Eclipse编译器</li></ul><p>为什么要安装 Gradle 环境，因为 spring 项目时用 gradle 管理的并不是 maven</p><p>没用过Gradle？没事我也没用过，你不需要多么精通，介绍个大概：12年基于 Ant 和 Maven 产生的 Gradle，弥补了 Ant 和 Maven 的不足，maven应该熟悉吧，其实都差不多，Gradle 目前以面向 Java 为主</p><p>推荐阅读：<a href="https://www.jianshu.com/p/001abe1d8e95" target="_blank" rel="noopener">Gradle 入门–只此一篇</a>，有个大概印象就行</p><h2 id="第一步–下载spring源码"><a href="#第一步–下载spring源码" class="headerlink" title="第一步–下载spring源码"></a>第一步–下载spring源码</h2><p>你可以直接去 github 上去下载源码：<a href="https://github.com/spring-projects/spring-framework" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework</a></p><p>也可以用 git 命令 clone 下来：（不过这样会很慢推荐上一种直接下载）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/spring-projects/spring-framework.git</span><br></pre></td></tr></table></figure><h2 id="第二步–安装-Gradle"><a href="#第二步–安装-Gradle" class="headerlink" title="第二步–安装 Gradle"></a>第二步–安装 Gradle</h2><h3 id="官网下载"><a href="#官网下载" class="headerlink" title="官网下载"></a>官网下载</h3><p>直接去官网下载：<a href="https://gradle.org/" target="_blank" rel="noopener">Gradle官网</a></p><p><img alt="image-20200131120236025" data-src="https://cdn.kaiming66.com/%E6%90%AD%E5%BB%BAspring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83image-20200131120236025.jpg" class="lazyload"></p><h3 id="下载压缩包"><a href="#下载压缩包" class="headerlink" title="下载压缩包"></a>下载压缩包</h3><p>点进去后往下拉，找到如图所示的地方：</p><p><img alt="image-20200131120411311" data-src="https://cdn.kaiming66.com/%E6%90%AD%E5%BB%BAspring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83image-20200131120411311.png" class="lazyload"></p><h3 id="下载需要版本"><a href="#下载需要版本" class="headerlink" title="下载需要版本"></a>下载需要版本</h3><p>随便挑个版本，我这挑的是 5.4.1 的：</p><p><img alt="image-20200131120519163" data-src="https://cdn.kaiming66.com/%E6%90%AD%E5%BB%BAspring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83image-20200131120519163.png" class="lazyload"></p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>下载到随便一个地方然后解压，然后就是配置环境变量：</p><ul><li>Java 已经配了好多遍了吧，在系统变量的 path 那里新建一个环境变量，将你解压好的文件的 bin 的路径加上去</li></ul><p><img alt="image-20200131120821465" data-src="https://cdn.kaiming66.com/%E6%90%AD%E5%BB%BAspring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83image-20200131120821465.png" class="lazyload"></p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证一下是否安装</p><p><img alt="image-20200131121204168" data-src="https://cdn.kaiming66.com/%E6%90%AD%E5%BB%BAspring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83image-20200131121204168.png" class="lazyload"></p><p>OK，这样就算安装好了</p><h3 id="更换Gradle源为阿里源"><a href="#更换Gradle源为阿里源" class="headerlink" title="更换Gradle源为阿里源"></a>更换Gradle源为阿里源</h3><p>新建一个 init,gradle 文件，放到你的解压好的文件的 init.d 这里面</p><p><img alt="image-20200131122143335" data-src="https://cdn.kaiming66.com/%E6%90%AD%E5%BB%BAspring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83image-20200131122143335.png" class="lazyload"></p><p>文件内容为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenLocal()</span><br><span class="line">        maven &#123; url <span class="string">'http://maven.aliyun.com/nexus/content/repositories/central/'</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IDEA-配置-Gradle"><a href="#IDEA-配置-Gradle" class="headerlink" title="IDEA 配置 Gradle"></a>IDEA 配置 Gradle</h3><p>打开 setting -&gt; Gradle ，将bin目录下的 .gradle 路径加到这里 </p><p><img alt="image-20200131121346201" data-src="https://cdn.kaiming66.com/%E6%90%AD%E5%BB%BAspring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83image-20200131121346201.png" class="lazyload"></p><h2 id="第三步–导入Spring-源码"><a href="#第三步–导入Spring-源码" class="headerlink" title="第三步–导入Spring 源码"></a>第三步–导入Spring 源码</h2><p>使用 IDEA impot 项目，找到 build.gradle 选择它进行导入</p><p><img alt="image-20200131121656479" data-src="https://cdn.kaiming66.com/%E6%90%AD%E5%BB%BAspring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83image-20200131121656479.png" class="lazyload"></p><p>ok全部步骤完成，等待 Gradle 导入即可</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程--启动一个最简单的程序，有多少个线程被创建</title>
      <link href="/2020/01/26/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B--%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%A8%8B%E5%BA%8F%EF%BC%8C%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%A2%AB%E5%88%9B%E5%BB%BA/"/>
      <url>/2020/01/26/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B--%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%A8%8B%E5%BA%8F%EF%BC%8C%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%A2%AB%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程–启动一个最简单的程序，有多少个线程被创建"><a href="#多线程–启动一个最简单的程序，有多少个线程被创建" class="headerlink" title="多线程–启动一个最简单的程序，有多少个线程被创建"></a>多线程–启动一个最简单的程序，有多少个线程被创建</h1><blockquote><p>最近在看多线程并发，忽然看到了这个记录下来</p></blockquote><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadGroup g = Thread.currentThread().getThreadGroup();</span><br><span class="line">        <span class="keyword">while</span> (g != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ThreadGroup temp = g.getParent();</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            g = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"active count is :"</span>+ g.activeCount());</span><br><span class="line">        Thread[] all = <span class="keyword">new</span> Thread[g.activeCount()];</span><br><span class="line">        g.enumerate(all);</span><br><span class="line">        <span class="keyword">for</span> (Thread t:all) &#123;</span><br><span class="line">            System.out.println(t.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的意思是获取当前线程的线程组中所有活跃的线程，算上自己 main 函数本身一共有六个线程</p><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">active count is :<span class="number">6</span></span><br><span class="line">Reference Handler</span><br><span class="line">Finalizer</span><br><span class="line">Signal Dispatcher</span><br><span class="line">Attach Listener</span><br><span class="line">main</span><br><span class="line">Monitor Ctrl-Break</span><br></pre></td></tr></table></figure><p>从网上搜集的对各个线程的解释：</p><h2 id="Attach-Listener"><a href="#Attach-Listener" class="headerlink" title="Attach Listener"></a>Attach Listener</h2><p>Attach Listener线程是负责接收到外部的命令，而对该命令进行执行的并且吧结果返回给发送者。通常我们会用一些命令去要求jvm给我们一些反 馈信息，如：java -version、jmap、jstack等等。如果该线程在jvm启动的时候没有初始化，那么，则会在用户第一次执行jvm命令时，得到启动。</p><h2 id="Signal-Dispatcher"><a href="#Signal-Dispatcher" class="headerlink" title="Signal Dispatcher"></a>Signal Dispatcher</h2><p>前面我们提到第一个Attach Listener线程的职责是接收外部jvm命令，当命令接收成功后，会交给signal dispather线程去进行分发到各个不同的模块处理命令，并且返回处理结果。signal dispather线程也是在第一次接收外部jvm命令时，进行初始化工作。</p><h2 id="Finalizer"><a href="#Finalizer" class="headerlink" title="Finalizer"></a>Finalizer</h2><p>这个线程也是在main线程之后创建的，其优先级为10，主要用于在垃圾收集前，调用对象的finalize()方法；关于Finalizer线程的几点：</p><ol><li><p>只有当开始一轮垃圾收集时，才会开始调用finalize()方法；因此并不是所有对象的finalize()方法都会被执行；</p></li><li><p>该线程也是daemon线程，因此如果虚拟机中没有其他非daemon线程，不管该线程有没有执行完finalize()方法，JVM也会退出；</p></li><li><p>JVM在垃圾收集时会将失去引用的对象包装成Finalizer对象（Reference的实现），并放入ReferenceQueue，由Finalizer线程来处理；最后将该Finalizer对象的引用置为null，由垃圾收集器来回收；</p></li><li><p>JVM为什么要单独用一个线程来执行finalize()方法呢？如果JVM的垃圾收集线程自己来做，很有可能由于在finalize()方法中误操作导致GC线程停止或不可控，这对GC线程来说是一种灾难；</p></li></ol><h2 id="Reference-Handler"><a href="#Reference-Handler" class="headerlink" title="Reference Handler"></a>Reference Handler</h2><p>VM在创建main线程后就创建Reference Handler线程，其优先级最高，为10，它主要用于处理引用对象本身（软引用、弱引用、虚引用）的垃圾回收问题。</p><h2 id="Monitor-Ctrl-Break"><a href="#Monitor-Ctrl-Break" class="headerlink" title="Monitor Ctrl-Break"></a>Monitor Ctrl-Break</h2><p>这个线程我也不是很明白是干什么用的，oracle官网有详细信息，大家可以去看看<br><a href="https://link.jianshu.com/?t=http://docs.oracle.com/cd/E13188_01/jrockit/docs50/userguide/apstkdmp.html" target="_blank" rel="noopener">详细链接</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring属性注入</title>
      <link href="/2020/01/23/Java/%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5/"/>
      <url>/2020/01/23/Java/%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="spring的属性注入"><a href="#spring的属性注入" class="headerlink" title="spring的属性注入"></a>spring的属性注入</h1><ul><li>spring框架目前支持两种注入方式<ul><li>set方式注入（常用）</li><li>有参构造函数注入</li></ul></li></ul><h2 id="set方式注入（常用）"><a href="#set方式注入（常用）" class="headerlink" title="set方式注入（常用）"></a>set方式注入（常用）</h2><p>这个比较简单，两幅图带过，原理是通过对应属性的 set 方法来注入</p><p>spring配置文件的写法：</p><p><img alt="image" data-src="https://cdn.kaiming66.com/spring%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5set%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%85%A5.jpg" class="lazyload"></p><p>后面那些初始化方法，销毁方法以及作用域忽视掉这里没啥用</p><p>People类：</p><p><img alt="image" data-src="https://cdn.kaiming66.com/spring%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5people.jpg" class="lazyload"></p><p>自己测试的话就要实例化一个容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ct = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:bean.xml"</span>);</span><br><span class="line">People people = (People) ct.getBean(<span class="string">"people"</span>);</span><br><span class="line">System.out.println(people);</span><br></pre></td></tr></table></figure><h2 id="有参构造函数方式注入"><a href="#有参构造函数方式注入" class="headerlink" title="有参构造函数方式注入"></a>有参构造函数方式注入</h2><p>这个没有上一个常用但是我们见到了以后也要知道</p><p>spring配置文件写法：</p><p><img alt="image-20200129134330532" data-src="https://cdn.kaiming66.com/spring%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%85%A5.jpg" class="lazyload"></p><p>PropertyDemo1类：</p><p><img alt="image-20200129135048657" data-src="https://cdn.kaiming66.com/spring%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5propertyDemo1.jpg" class="lazyload"></p><p>这里用的标签是 consructor-arg，通过测试一样可以注入</p><h2 id="注入对象类型参数"><a href="#注入对象类型参数" class="headerlink" title="注入对象类型参数"></a>注入对象类型参数</h2><p>上面两种都是String类型的属性注入，比如说我想在 UserService 中调用 UserDao 的 add 方法，我要把他注入进来这该怎么做？</p><p>其实同理把实例化的过程交给 spring，让他来帮助我们实例化，我们只管调用就行</p><p>spring配置文件写法：</p><p><img alt="image" data-src="https://cdn.kaiming66.com/spring%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5.jpg" class="lazyload"></p><p>UserService类：</p><p><img alt="image" data-src="https://cdn.kaiming66.com/spring%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5UserService.jpg" class="lazyload"></p><p>UserDao类：</p><p><img alt="image-20200129135450249" data-src="https://cdn.kaiming66.com/spring%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5UserDao.jpg" class="lazyload"></p><p>对象类型的注入，也就是在类里定义一个要调用的类的属性，并给出set方法，然后spring通过set方法注入</p><h2 id="P名称空间注入"><a href="#P名称空间注入" class="headerlink" title="P名称空间注入"></a>P名称空间注入</h2><p>这个方法不怎么用过，简单记录一下，首先我们在配置文件上面 beans 标签的命名空间那里加一行，如下图：</p><p><img alt="image" data-src="https://cdn.kaiming66.com/spring%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5p%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4(1).jpg" class="lazyload"></p><p><img alt="image" data-src="https://cdn.kaiming66.com/spring%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5p%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4(2).jpg" class="lazyload"></p><p>Person类：</p><p><img alt="image" data-src="https://cdn.kaiming66.com/spring%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5Person.jpg" class="lazyload"></p><p>通过这种方式也能达到属性的注入</p><h2 id="各种复杂类型的属性注入"><a href="#各种复杂类型的属性注入" class="headerlink" title="各种复杂类型的属性注入"></a>各种复杂类型的属性注入</h2><p>感觉比较有用记录一下，也是通过set方式注入</p><h3 id="Person类"><a href="#Person类" class="headerlink" title="Person类"></a>Person类</h3><p><img alt="image-20200129142156169" data-src="https://cdn.kaiming66.com/spring%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5person(2).jpg" class="lazyload"></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><img alt="image" data-src="https://cdn.kaiming66.com/spring%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5%E6%95%B0%E7%BB%84.jpg" class="lazyload"></p><h3 id="list集合"><a href="#list集合" class="headerlink" title="list集合"></a>list集合</h3><p><img alt="image" data-src="https://cdn.kaiming66.com/spring%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5list.jpg" class="lazyload"></p><h3 id="map集合"><a href="#map集合" class="headerlink" title="map集合"></a>map集合</h3><p><img alt="image" data-src="https://cdn.kaiming66.com/spring%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5map.jpg" class="lazyload"></p><h3 id="properties类型"><a href="#properties类型" class="headerlink" title="properties类型"></a>properties类型</h3><p><img alt="image" data-src="https://cdn.kaiming66.com/spring%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5properties.jpg" class="lazyload"></p><p>简单测试一下：</p><p><img alt="image" data-src="https://cdn.kaiming66.com/spring%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5test.jpg" class="lazyload"></p><p>完美！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合--HashMap</title>
      <link href="/2020/01/15/Java/%E9%9B%86%E5%90%88--HashMap/"/>
      <url>/2020/01/15/Java/%E9%9B%86%E5%90%88--HashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="集合–HashMap"><a href="#集合–HashMap" class="headerlink" title="集合–HashMap"></a>集合–HashMap</h1><blockquote><p>基于JDK 1.8 版本，会有与以前版本的比较</p></blockquote><p>&emsp;&emsp;HashMap 使我们非常常用的一个存储 key value 的数据结构，是由数组和链表组合构成。在JDK 8 中对 HashMap 进行了优化引入了红黑树，哈希冲突的解决办法 —— 冲突链表法。</p><p>（这里借用帅丙几张图）</p><p><img alt="006tNbRwly1g9pchhbrp3j30ez02ngli" data-src="https://cdn.kaiming66.com/%E9%9B%86%E5%90%88-006tNbRwly1g9pchhbrp3j30ez02ngli.jpg" class="lazyload"></p><p>&emsp;&emsp;在我们执行 put 的方法时比如 put（ “帅丙”, 520 ），就是往这个数组中取填通过 HashMap 的 hash 方法对 key 进行计算得出下标，<code>hash(&quot;帅丙&quot;)=2</code></p><p><img alt="006tNbRwly1g9pcqyo35ij30et03d0sq" data-src="https://cdn.kaiming66.com/%E9%9B%86%E5%90%88-006tNbRwly1g9pcqyo35ij30et03d0sq.jpg" class="lazyload"></p><h3 id="hash函数-amp-计算下标公式："><a href="#hash函数-amp-计算下标公式：" class="headerlink" title="hash函数 &amp; 计算下标公式："></a>hash函数 &amp; 计算下标公式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">//hash函数返回的是 key 的 hashCode 与高十六位进行异或，又称二次扰动</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下标计算公式</span></span><br><span class="line">index = HashCode（Key） &amp; （Length - <span class="number">1</span>）<span class="comment">//等价于 HashCode（Key）% length</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;数组的长度是有限的，而且利用哈希算法计算下标也是会发生冲突的，上面介绍过解决冲突的办法是冲突链表法，当两个 key 的下标计算一样时就会发生冲突，这时我们会通过头插法（JDK1.8以前是这样的，JDK1.8改为尾插法）形成链表。</p><p><img alt="006tNbRwly1g9pd6ckj3dj30eq06mmx8" data-src="https://cdn.kaiming66.com/%E9%9B%86%E5%90%88-006tNbRwly1g9pd6ckj3dj30eq06mmx8.jpg" class="lazyload"></p><p>&emsp;&emsp;像这样每一个 key value 结构在 JDK 1.8 中叫做 Node（实现了 Map.Entry 接口） ，以前的版本叫做 Entry，结构源码如下：</p><h3 id="Node结构"><a href="#Node结构" class="headerlink" title="Node结构"></a>Node结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在JDK 1.8 中引入的红黑树巧妙的将时间复杂度从<code>O(n)</code>降到了<code>O(logn)</code>，在链表长度达到 8 时就会将链表转换成红黑树，结点从 Node 都转变为 TreeNode，如果链表长度降为 6 那么会转变回链表结构，7 的话就保持原状。这是根据泊松分布计算得出的，在负载因子为 0.75 的时候，单个 hash 槽内的个数为 8 的概率小于百万分之一，所以将 7 作为一个分水岭。</p><ul><li>通过上面的介绍应该对 HashMap 有了个基本的认识，接下来介绍一些基本的知识点</li></ul><h3 id="为什么-HashMap-的容量都是-2-的幂次方"><a href="#为什么-HashMap-的容量都是-2-的幂次方" class="headerlink" title="为什么 HashMap 的容量都是 2 的幂次方"></a>为什么 HashMap 的容量都是 2 的幂次方</h3><p>&emsp;&emsp;因为 2 的幂次方时，我们在求下标的时候进行减一处理后，二进制的表示都是 1 ，这样的话 index 的值就取决于 hashCode 的值，只要 hashCode 是均匀的那么 index 就是均匀，这就是为了实现均匀分布。</p><h3 id="HashMap-扩容机制（resize）"><a href="#HashMap-扩容机制（resize）" class="headerlink" title="HashMap 扩容机制（resize）"></a>HashMap 扩容机制（resize）</h3><ul><li>Capacity：HashMap当前长度。</li><li>LoadFactor：负载因子，默认值0.75f。</li></ul><p>&emsp;&emsp;HashMap 的初始大小是 16，负载因子为 0.75，源码中有一句话<code>The next size value at which to resize (capacity * load factor).</code>它是通过对比当前 map 中的 size 大小 和 容量 * 负载因子进行对比，如果大了就扩容。就比如说容量为 100，在我存入第 76 个时就会发生扩容。</p><p>扩容分为两步：</p><ul><li>扩容创建一个新的 Entry 或者叫 Node 新数组，长度是原来的两倍</li><li>ReHash：遍历原 Entry 数组 ，并把所有 Entry 重新 Hash 一遍到 新数组中</li></ul><h4 id="为什么要重新-Hash-呢？"><a href="#为什么要重新-Hash-呢？" class="headerlink" title="为什么要重新 Hash 呢？"></a>为什么要重新 Hash 呢？</h4><p>&emsp;&emsp;因为我们上面已经讲过了下标的算法，index  = hash(key) &amp; length -1，这里也是经过优化的 在数组长度为 2 的指数时，hash(key) % length 对长度取模结果和 &amp; 运算一样，但是位运算的效率更高这也是为了性能考虑。在这里我们可以看到数组扩容了那么长度也会发生改变，这时我们就需要重新 hash 存到数组中。</p><h3 id="为什么以前使用头插法后来改为了尾插法，目的是什么？"><a href="#为什么以前使用头插法后来改为了尾插法，目的是什么？" class="headerlink" title="为什么以前使用头插法后来改为了尾插法，目的是什么？"></a>为什么以前使用头插法后来改为了尾插法，目的是什么？</h3><p>&emsp;&emsp;头插法原本是作者考虑热点数据的，他认为后来的可能用到的概率更大。但是后来发现会出现死循环的问题，在多个线程下进行 resize 时，当线程调节完后可能就会形成一个环形链表。而尾插法的话在扩容完后还会元素原本的顺序，就不会出现成环的情况了。</p><h3 id="那既然解决了多线程下的死循环，那是不是JDK8的HashMap就能用在多线程的环境下了呢？"><a href="#那既然解决了多线程下的死循环，那是不是JDK8的HashMap就能用在多线程的环境下了呢？" class="headerlink" title="那既然解决了多线程下的死循环，那是不是JDK8的HashMap就能用在多线程的环境下了呢？"></a>那既然解决了多线程下的死循环，那是不是JDK8的HashMap就能用在多线程的环境下了呢？</h3><p>&emsp;&emsp;源码中看到方法中都没有进行同步，那么可能造成的现象就是，无法保证读取的值我们下一秒操作时还是原来的值。或者上一秒 put 的值，下一秒我们 get 时还是原值，所以线程安全还是无法保证。</p><h3 id="为什么-hash-函数计算-hash-值的时候要无符号右移-16-位再异或？"><a href="#为什么-hash-函数计算-hash-值的时候要无符号右移-16-位再异或？" class="headerlink" title="为什么 hash 函数计算 hash 值的时候要无符号右移 16 位再异或？"></a>为什么 hash 函数计算 hash 值的时候要无符号右移 16 位再异或？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;还是上面的那段代码这里有好多种解释，其中有种解释是这样的因为我们平常的 map 长度也不会超过 2 的十六次方即 65536 这么长，那么计算下标时只会和低十六位进行 &amp; 运算，这样高位就很少进入运算。其实总的方向就是为了使全部的 hash 值参与运算使 hash 分布的更平均。</p><h3 id="为什么下标-index-计算要取模运算？"><a href="#为什么下标-index-计算要取模运算？" class="headerlink" title="为什么下标 index 计算要取模运算？"></a>为什么下标 index 计算要取模运算？</h3><p>&emsp;&emsp;如果直接把上面 hash 函数计算后的值当做下标，范围为 <strong>-2147483648</strong>到<strong>2147483648</strong> ，大约 40 亿空间。确实如果映射均匀很难碰撞但是，这么大的范围是没办法存入内存中的所以采用了 hash % length 这种格式，即 hash &amp; length -1</p><h3 id="HashMap-在-put-时是如何计算下标和判断对象是同一对象？"><a href="#HashMap-在-put-时是如何计算下标和判断对象是同一对象？" class="headerlink" title="HashMap 在 put 时是如何计算下标和判断对象是同一对象？"></a>HashMap 在 put 时是如何计算下标和判断对象是同一对象？</h3><p>&emsp;&emsp;在计算下标时首先判断对象是不是 null，如果是 null 则 hashCode 为 0 ，如果不是则正常计算。判断同一对象首先判断他们的 hash 值是否相同，如果相同则再调用 equals 方法判断是否真正相同。</p><h3 id="拿-HashMap-举例，为什么重写-equals-时还得重写-hashCode-方法？"><a href="#拿-HashMap-举例，为什么重写-equals-时还得重写-hashCode-方法？" class="headerlink" title="拿 HashMap 举例，为什么重写 equals 时还得重写 hashCode 方法？"></a>拿 HashMap 举例，为什么重写 equals 时还得重写 hashCode 方法？</h3><p>&emsp;&emsp;比如说 hashMap，我们是通过 hash 函数计算出 index 去寻找对象的位置，但是如果像上面说的可能会冲突后在后边形成链表，那么这时该如何区分对象。<strong>equals！</strong>这时就该我们大 equals 出场来判断了，如果你不吧这两个方法一块重写的话，遇见这种情况就没有办法找到真正的对象了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lombok使用可能遇到的坑</title>
      <link href="/2020/01/15/Java/lombok%E7%9A%84%E5%9D%91/"/>
      <url>/2020/01/15/Java/lombok%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h1 id="lombok使用可能遇到的坑"><a href="#lombok使用可能遇到的坑" class="headerlink" title="lombok使用可能遇到的坑"></a>lombok使用可能遇到的坑</h1><p>参考链接:<a href="https://www.bianxiaofeng.com/article/78" target="_blank" rel="noopener">https://www.bianxiaofeng.com/article/78</a></p><p>无意间逛博客发现一个以前在项目中看到的注解，当时还不理解为什要加@EqualsAndHashCode(callSuper = true)，正好写个例子记录一下。</p><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><p>在日常使用中会经常用到以下注解:</p><ol><li><strong>@Data</strong>: 用在类上,用于生成setter/getter/equals/canEqual/hashCode/toString 方法,如果字段为<code>final</code>属性则不会为它生成get/set方法.</li><li><strong>@Setter</strong> 用在类或字段，注解在类时为所有字段生成setter方法，注解在字段上时只为该字段生成setter方法。</li><li><strong>@Getter</strong> 用在类或字段，注解在类时为所有字段生成getter方法，注解在字段上时只为该字段生成getter方法。</li><li><strong>@ToString</strong> 用在类上，用于生成toString方法。</li><li><strong>@EqualsAndHashCode</strong> 用在类上，生成hashCode和equals方法。</li><li><strong>@NoArgsConstructor</strong> 用在类上，生成无参的构造方法。</li><li><strong>@RequiredArgsConstructor</strong> 用在类上，为类中需要特殊处理的字段生成构造方法，比如final和被@NonNull注解的字段。</li><li><strong>@AllArgsConstructor</strong> 用在类上，生成包含类中所有字段的构造方法。</li><li><strong>@Slf4j</strong> 用在类上，生成log变量，严格意义来说是常量。<code>private static final Logger log = LoggerFactory.getLogger(UserController.class);</code></li></ol><ul><li>平常我使用的时候只是在实体类上加一个@Data，它包括了setter、getter、toString、EqualsAndHashCode等。</li></ul><h2 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h2><p>​    在使用Javac进行编译的过程中会先对源代码进行分析,生成一个抽象语法树(AST),然后调用实现了”JSR 269 API”的Lombok程序,接着之前生成的抽象语法树进行处理,在使用了@Data等注解的类的语法树上进行修改,追加相应的get/set方法的对应数节点.然后使用修改后的抽象语法树生成字节码.</p><h2 id="EqualsAndHashCode的坑："><a href="#EqualsAndHashCode的坑：" class="headerlink" title="@EqualsAndHashCode的坑："></a>@EqualsAndHashCode的坑：</h2><p>举个例子，编写一个父类和一个继承它的子类。</p><h3 id="测试父类："><a href="#测试父类：" class="headerlink" title="测试父类："></a>测试父类：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSuper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试子类："><a href="#测试子类：" class="headerlink" title="测试子类："></a>测试子类：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleTestSuper</span> <span class="keyword">extends</span> <span class="title">TestSuper</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppleTestSuper</span><span class="params">(Integer id,String name,String code,Integer age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id,name);</span><br><span class="line">        <span class="keyword">this</span>.code=code;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="main函数："><a href="#main函数：" class="headerlink" title="main函数："></a>main函数：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AppleTestSuper appleTestSuper = <span class="keyword">new</span> AppleTestSuper(<span class="number">1</span>,<span class="string">"ccc"</span>,<span class="string">"321"</span>,<span class="number">11</span>);</span><br><span class="line">        AppleTestSuper appleTestSuper1 = <span class="keyword">new</span> AppleTestSuper(<span class="number">2</span>,<span class="string">"ccc"</span>,<span class="string">"321"</span>,<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(appleTestSuper.equals(appleTestSuper1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><p>true</p><p>很明显不相等的两个类为什么equals返回为true，正好学习了一下如何反编译class文件，IDEA编译器自带了反编译的工具，可以在setting里的plugins里搜索byte看到下图</p><p><img alt="image-1" data-src="https://cdn.kaiming66.com/lombok.jpg" class="lazyload"></p><p>或者下载一个JD-GUI，也叫Java Decompiler，直接打开class文件就能反编译成java文件了</p><p><img alt="image-2" data-src="https://cdn.kaiming66.com/javaDecompiler.jpg" class="lazyload"></p><h3 id="反编译后的-equals-代码："><a href="#反编译后的-equals-代码：" class="headerlink" title="反编译后的 equals 代码："></a>反编译后的 equals 代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> AppleTestSuper)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AppleTestSuper other = (AppleTestSuper)o;</span><br><span class="line">            <span class="keyword">if</span> (!other.canEqual(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Object <span class="keyword">this</span>$code = <span class="keyword">this</span>.getCode();</span><br><span class="line">                Object other$code = other.getCode();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>$code == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (other$code != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>$code.equals(other$code)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Object <span class="keyword">this</span>$age = <span class="keyword">this</span>.getAge();</span><br><span class="line">                Object other$age = other.getAge();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>$age == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (other$age != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>$age.equals(other$age)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里只比较了子类中的两个属性，并未比较父类中的属性，所以我们会发生上面的错误</p><p>Lombok有@EqualsAndHashCode注解,而@Data这一个注解就包括了@EqualAndHashCode,而@EqualAndHashCode这个注解中有一个<code>callSuper</code>属性,这个属性就是用于判断是否需要在子类的equals方法中加入父类字段的判断,而该属性的默认值为false.</p><p>所以在AppleComputer类上添加<code>@EqualsAndHashCode(callSuper = true)</code>后再运行下main方法,结果为<strong>false</strong>.</p><p>再次反编译后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> AppleTestSuper)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AppleTestSuper other = (AppleTestSuper)o;</span><br><span class="line">            <span class="keyword">if</span> (!other.canEqual(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">super</span>.equals(o)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Object <span class="keyword">this</span>$code = <span class="keyword">this</span>.getCode();</span><br><span class="line">                Object other$code = other.getCode();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>$code == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (other$code != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>$code.equals(other$code)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Object <span class="keyword">this</span>$age = <span class="keyword">this</span>.getAge();</span><br><span class="line">                Object other$age = other.getAge();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>$age == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (other$age != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>$age.equals(other$age)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到多了一句 if-else 的判断父类的语句，这样就正常了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在继承父类的子类中我们不仅要加@Data，同时也要@EqualsAndHashCode(callSuper = true)，这样做就完全o鸡儿k了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> lombok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合--ArrayList</title>
      <link href="/2020/01/12/Java/%E9%9B%86%E5%90%88--ArrayList/"/>
      <url>/2020/01/12/Java/%E9%9B%86%E5%90%88--ArrayList/</url>
      
        <content type="html"><![CDATA[<h1 id="集合–ArrayList"><a href="#集合–ArrayList" class="headerlink" title="集合–ArrayList"></a>集合–ArrayList</h1><blockquote><p>主要内容基于 JDK 1.8 下的特性，总结于<a href="https://blog.csdn.net/qq_35190492/article/details/103883964" target="_blank" rel="noopener">《阿里面试问了ArrayList，都问了啥？》</a></p></blockquote><p>先聊一聊基本概念：</p><ul><li>底层是用数组实现</li><li>查询快，增删慢</li><li>不是线程安全，但是效率高</li></ul><blockquote><p>为什么遍历快？</p></blockquote><p>&emsp;&emsp;论遍历要比 LinkedList 快，因为是用数组实现，内部内存连续，而 CPU 的局部性的机制会缓存连续的内存地址，大幅降低了读取内存的开销。</p><blockquote><p>为什么线程不安全还要用？</p></blockquote><p>&emsp;&emsp;因为日常开发中查询是用的最多的，不太会频繁的进行增删，如果增删频繁的话就用 LinkedList，如果想要线程安全的话那么就用 Vector ，这也是他们仨主要的区别。</p><blockquote><p>ArrayList 的扩容机制</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从源代码中就能很好看出，JDK1.8的扩容效率很高，因为采用了位运算右移 1 位，因为计算机中都是补码的二进制嘛，所以右移 1 位就相当于 / 2，那么这里就是 1.5 倍扩容，如果还是不够就按设置的最小容量扩容。</p><blockquote><p>JDK 1.7 和 JDK 1.8 初始化的区别</p></blockquote><p>&emsp;&emsp;ArrayList 在 1.7 以前初始化时会调用 this(10) 来直接初始化一个容量为 10 的数组，而在 1.7 及以后初始化时默认走了一个空数组，在第一次 add 后容量才会变成默认容量 10。</p><blockquote><p>为什么增删慢呢？</p></blockquote><p><img alt="image-20200227235902194" data-src="https://cdn.kaiming66.com/%E9%9B%86%E5%90%88-image-20200227235902194.png" class="lazyload"></p><p>&emsp;&emsp;阅读源码就可以知道，在指定下标处增加或者删除元素时，都是 copy 数组，无非是增加时是把 index 以后的数组复制到 index+1 的位置，而删除时就是直接把 index 后的数组复制到 index-1 的位置，直接覆盖掉，然后把最后置为 null。</p><blockquote><p><code>ArrayList(int initialCapacity)</code> 会不会初始化数组？</p></blockquote><p>源码部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到的确初始化了一个数组，但是 list 的 size 并没有初始化还是 0 ，所以当你 set( 5 ,1) （随便挑个值）的时候，它的第一行代码就是检查 index 下标和 size 的关系，这时就会报<code>下标越界的异常</code></p><p>&emsp;&emsp;结论就是会初始化数组，但没有初始化 list</p><blockquote><p>ArrayList 删除一定慢吗？</p></blockquote><p>&emsp;&emsp;不一定，看删除的位置离末尾的距离，ArrayList 很适合作堆栈，pop、push 都不会涉及数据的移动，所以也不适合作队列，因为涉及的数据移动太多，但是数组适合做队列。</p><p>&emsp;&emsp;想要线程安全就使用 Vector（它的扩容机制是翻倍，并不是 1.5 倍），实现很简单就是把方法都加上 synchronized 关键字，或者也可以用 <code>Collections.synchronizeList</code> 来包装成线程安全的 list。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--布隆过滤器</title>
      <link href="/2019/12/15/redis/Redis--%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2019/12/15/redis/Redis--%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis–集成布隆过滤器"><a href="#Redis–集成布隆过滤器" class="headerlink" title="Redis–集成布隆过滤器"></a>Redis–集成布隆过滤器</h1><blockquote><p>总结于《<a href="https://juejin.im/book/5afc2e5f6fb9a07a9b362527" target="_blank" rel="noopener">Redis 深度历险：核心原理与应用实践</a>》</p></blockquote><h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><ul><li>我们在推荐不重复的热点内容给用户观看，避免重复推送。</li><li>或者判断一个信息是否在黑名单或白名单中</li></ul><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>&emsp;&emsp;对于上一个场景我们可能想到缓存，来缓存每次用户看过的数据，但是时间一长缓存也会变的非常大浪费空间。</p><p>&emsp;&emsp;这个时候布隆过滤器就出场了，它可以节省 90 % 的空间，只不过可能存在一些误判的情况。</p><p>&emsp;&emsp;布隆过滤器可以看作是一个不是百分百精确的一个 Set 集合，当使用它的 contains 方法时可能会出现误判的情况，但是这种误判也可以通过参数的设置把概率降的很低。</p><p>&emsp;&emsp;可以这么理解布隆过滤器说他不存在，那么他就一定不存在；如果说他存在，那么他有一定几率不存在。有点宁错杀三千不放过一个的意思。</p><p>&emsp;&emsp;这个特性可以用在推送上面，比如客户每天收到推荐的新消息如何做到不重复。我们可能会想到用 SQL 语句中的 exists 来判断是否存在，但是性能上数据库并不能扛住很高的并发量。这时就可以用布隆过滤器来进行过滤，筛选出用户没有看过的信息。</p><h2 id="bloom-filter-的使用"><a href="#bloom-filter-的使用" class="headerlink" title="bloom filter 的使用"></a>bloom filter 的使用</h2><ul><li>首先要确保安装 <code>redis 4.0</code> 以上的版本，因为 4 及以上的版本才支持布隆插件。<a href="http://download.redis.io/releases/" target="_blank" rel="noopener">下载链接</a></li><li>我这里下载的是 5.0.5 版本，基本的安装教程略过网上有很多，这里讲一下插件的安装</li></ul><h3 id="第一步：下载插件"><a href="#第一步：下载插件" class="headerlink" title="第一步：下载插件"></a>第一步：下载插件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/RedisLabsModules/rebloom/archive/v1.1.1.tar.gz</span><br></pre></td></tr></table></figure><h3 id="第二步：解压并安装，生成-so-文件"><a href="#第二步：解压并安装，生成-so-文件" class="headerlink" title="第二步：解压并安装，生成 so 文件"></a>第二步：解压并安装，生成 so 文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@redis]<span class="comment"># tar -zxvf v1.1.1.tar.gz</span></span><br><span class="line">[root@redis]<span class="comment"># cd RedisBloom-1.1.1/</span></span><br><span class="line">[root@RedisBloom-1.1.1]<span class="comment"># ls</span></span><br><span class="line">contrib  Dockerfile  docs  LICENSE  Makefile  mkdocs.yml  ramp.yml  README.md  rebloom.so  src  tests</span><br></pre></td></tr></table></figure><h3 id="第三步：找到配置文件（redis-conf）加入该模块"><a href="#第三步：找到配置文件（redis-conf）加入该模块" class="headerlink" title="第三步：找到配置文件（redis.conf）加入该模块"></a>第三步：找到配置文件（redis.conf）加入该模块</h3><ul><li>根据自己的目录情况，我的配置文件是在 /usr/local/redis/bin 下的</li><li>下载的插件在 /opt/redis/ 下面</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@redis]<span class="comment"># cd /usr/local/redis/bin</span></span><br><span class="line">[root@bin]<span class="comment"># ls</span></span><br><span class="line">redis.conf</span><br><span class="line">[root@bin]<span class="comment"># vim redis.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#####################MODULES####################             </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># it will abort. It is possible to use multiple loadmodule directives.</span></span><br><span class="line"><span class="comment"># 这里改成自己插件的所在位置</span></span><br><span class="line">loadmodule /opt/redis/RedisBloom-1.1.1/rebloom.so</span><br></pre></td></tr></table></figure><h3 id="第四步：启动-redis-即可"><a href="#第四步：启动-redis-即可" class="headerlink" title="第四步：启动 redis 即可"></a>第四步：启动 redis 即可</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@bin]<span class="comment"># ./redis-server redis.conf</span></span><br></pre></td></tr></table></figure><h3 id="第五步：验证是否启用成功"><a href="#第五步：验证是否启用成功" class="headerlink" title="第五步：验证是否启用成功"></a>第五步：验证是否启用成功</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; bf.add users user1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.add users user2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.add users user3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; BF.EXISTS users user4</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; BF.EXISTS users user3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Java 客户端 Jedis-2.x 没有提供指令扩展机制，所以你无法直接使用 Jedis 来访问 Redis Module 提供的 <a href="http://bf.xxx/" target="_blank" rel="noopener">bf.xxx</a> 指令。RedisLabs 提供了一个单独的包 <a href="https://github.com/RedisLabs/JReBloom" target="_blank" rel="noopener">JReBloom</a>，但是它是基于 Jedis-3.0，Jedis-3.0 这个包目前还没有进入 release，没有进入 maven 的中央仓库，需要在 Github 上下载。在使用上很不方便，如果怕麻烦，还可以使用 <a href="https://github.com/lettuce-io/lettuce-core" target="_blank" rel="noopener">lettuce</a>，它是另一个 Redis 的客户端，相比 Jedis 而言，它很早就支持了指令扩展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BloomTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Client client = <span class="keyword">new</span> Client();</span><br><span class="line"></span><br><span class="line">    client.delete(<span class="string">"codehole"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">      client.add(<span class="string">"codehole"</span>, <span class="string">"user"</span> + i);</span><br><span class="line">      <span class="keyword">boolean</span> ret = client.exists(<span class="string">"codehole"</span>, <span class="string">"user"</span> + i);</span><br><span class="line">      <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    client.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们使用的是默认参数下的布隆过滤器，在 add 之前执行<code>bf.reserve</code>可以显示的设置参数来进一步降低误判率，如果已经有 key 则会报错。<code>bf.reserve</code>有三个参数分别是：<code>key</code>、<code>error_rate</code>、<code>initial_size</code>。错误率越低需要的空间越大<code>initial_size</code>参数表示预计放入的元素数量，当实际数量超出这个数值时，误判率会上升。</p><p>&emsp;&emsp;默认情况下的<code>error_rate</code>是 0.01，默认的<code>initial_size</code>是 100。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BloomTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String chars;</span><br><span class="line">  &#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">      builder.append((<span class="keyword">char</span>) (<span class="string">'a'</span> + i));</span><br><span class="line">    &#125;</span><br><span class="line">    chars = builder.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">randomString</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> idx = ThreadLocalRandom.current().nextInt(chars.length());</span><br><span class="line">      builder.append(chars.charAt(idx));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">randomUsers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">      users.add(randomString(<span class="number">64</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> users;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BloomTest bloomer = <span class="keyword">new</span> BloomTest();</span><br><span class="line">    List&lt;String&gt; users = bloomer.randomUsers(<span class="number">100000</span>);</span><br><span class="line">    List&lt;String&gt; usersTrain = users.subList(<span class="number">0</span>, users.size() / <span class="number">2</span>);</span><br><span class="line">    List&lt;String&gt; usersTest = users.subList(users.size() / <span class="number">2</span>, users.size());</span><br><span class="line"></span><br><span class="line">    Client client = <span class="keyword">new</span> Client();</span><br><span class="line">    client.delete(<span class="string">"codehole"</span>);</span><br><span class="line">    <span class="comment">// 对应 bf.reserve 指令</span></span><br><span class="line">    client.createFilter(<span class="string">"codehole"</span>, <span class="number">50000</span>, <span class="number">0.001</span>);</span><br><span class="line">    <span class="keyword">for</span> (String user : usersTrain) &#123;</span><br><span class="line">      client.add(<span class="string">"codehole"</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> falses = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String user : usersTest) &#123;</span><br><span class="line">      <span class="keyword">boolean</span> ret = client.exists(<span class="string">"codehole"</span>, user);</span><br><span class="line">      <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        falses++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.printf(<span class="string">"%d %d\n"</span>, falses, usersTest.size());</span><br><span class="line">    client.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>&emsp;&emsp;布隆过滤器的<code>initial_size</code>估计的过大，会浪费存储空间，估计的过小，就会影响准确率，用户在使用之前一定要尽可能地精确估计好元素数量，还需要加上一定的冗余空间以避免实际元素可能会意外高出估计值很多。</p><p>&emsp;&emsp;布隆过滤器的<code>error_rate</code>越小，需要的存储空间就越大，对于不需要过于精确的场合，<code>error_rate</code>设置稍大一点也无伤大雅。比如在新闻去重上而言，误判率高一点只会让小部分文章不能让合适的人看到，文章的整体阅读量不会因为这点误判率就带来巨大的改变。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img alt="16464301a0e26416" data-src="https://cdn.kaiming66.com/redis-16464301a0e26416.jpg" class="lazyload"></p><p>&emsp;&emsp;他在 add key 的时候会借助多个 hash 函数进行 hash 运算，得到的值再去与数组长度取模得到一个位置，每个hash都会得到一个不同的位置，然后把这些数对应的位置置为 1 即可算 add 完成</p><p>&emsp;&emsp;当布隆过滤器询问这个 key 是否存在时，跟 add 一样把这几个 hash 都算出来，看如果有一个为 0 ，那么就判断没有，如果全部是 1 那么也只是极有可能存在，因为也要可能是其他的 key 导致。如果这个位数组比较稀疏，那么正确率就会比较大，如果比较拥挤那么正确率就会降低</p><p>&emsp;&emsp;使用时不要让实际元素远大于初始大小，当大于时就应该重建布隆过滤器，重新分配一个更大的size 的过滤器，再将历史元素批量 add进去（这就要求我们在其他存储器中记录所有元素），不过 error_rate不会因为数量超出而急剧增加，所以这就为重建提供了富裕的时间</p><h3 id="布隆过滤器对空间的简单计算"><a href="#布隆过滤器对空间的简单计算" class="headerlink" title="布隆过滤器对空间的简单计算"></a>布隆过滤器对空间的简单计算</h3><p>两个输入参数：预计的元素数量 n，第二个是错误率 f</p><p>两个输出参数：位数组的长度 l，hash函数数量 k</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">k=0.7\*(l/n)    <span class="comment"># 约等于</span></span><br><span class="line"></span><br><span class="line">f=0.6185^(l/n)  <span class="comment"># ^ 表示次方计算，也就是 math.pow</span></span><br></pre></td></tr></table></figure><p>位数组越长则错误率越低。</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>&emsp;&emsp;<strong>记住布隆过滤器不存储元素对象内容，仅仅是元素的“指纹”，大概2kb</strong></p><p><strong>&emsp;&emsp;而想用set实现去重的效果，要存储元素本身的内容就远不止2kb了所以布隆过滤器的空间优势很明显</strong></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>算法本身缺点：</p><ul><li>元素可以添加到集合中，但不能被删除。</li><li>匹配结果只能是“绝对不在集合中”，并不能保证匹配成功的值已经在集合中。</li><li>当集合快满时，即接近预估最大容量时，误报的概率会变大。</li><li>数据占用空间放大。一般来说，对于1％的误报概率，每个元素少于10比特，与集合中的元素的大小或数量无关。 - 查询过程变慢，hash函数增多，导致每次匹配过程，需要查找多个位（hash个数）来确认是否存在。</li></ul>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>细碎知识点--正则表达式</title>
      <link href="/2019/12/10/Java/%E7%BB%86%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9--%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/12/10/Java/%E7%BB%86%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9--%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>最近做一个爬虫的项目，里面的主体代码我基本没怎么看过，只是用它来爬取网上的数据，但是这个项目好像有些bug，数据库中的关键词字段是正确的但是，导出的 word 的文档却有些重复的数据把正常的数据挤掉了。但是好几百的数据挨个去对可太不现实了（好吧我自己手动对了500多个数错了十多个）,然后我就想我 Java 也不能白学啊，是时候解决些实际问题了。首先用Java的IO获取对应导出数据的路径下的所有文件的名字，但是这些文件名字都很规则，前面一段长度不定的汉字后面一串数字下划线和字母。那么这时候就想到了正则进行匹配来获取前面的汉字作为关键字存到 List 里，然后判断是否 contains，这样就能知道哪些被挤掉了。</p></blockquote><p>下面来整理一下基础语法，最后有一些常用的正则表达式</p><blockquote><p>总结自于：</p><p>​    <a href="https://blog.csdn.net/weixin_44588495/article/details/104081047" target="_blank" rel="noopener">总结：正则表达式（java演示）</a></p><p>​    <a href="https://www.cnblogs.com/mzmy/p/11201377.html" target="_blank" rel="noopener">正则表达式简单语法及常用正则表达式</a></p></blockquote><h2 id="常用的基本符号"><a href="#常用的基本符号" class="headerlink" title="常用的基本符号"></a>常用的基本符号</h2><p><code>^</code>：  表示匹配字符串的开始位置  (例外  用在中括号中[ ] 时,可以理解为取反,表示不匹配括号中字符串)</p><p><code>$</code>：  表示匹配字符串的结束位置</p><p><code>*</code>：  表示匹配 零次到多次</p><p><code>+</code>：  表示匹配 一次到多次 (至少有一次)</p><p><code>?</code>：  表示匹配零次或一次</p><p><code>.</code>：  表示匹配单个字符 </p><p><code>|</code>：  表示为或者,两项中取一项</p><p>(  ) 小括号表示匹配括号中全部字符</p><p>[  ] 中括号表示匹配括号中一个字符 范围描述 如[0-9 a-z A-Z]</p><p>{  } 大括号用于限定匹配次数  如 {n}表示匹配n个字符  {n,}表示至少匹配n个字符  {n,m}表示至少n,最多m</p><p>\  转义字符 如上基本符号匹配都需要转义字符  如 *  表示匹配*号</p><p>\w 表示英文字母和数字  \W  非字母和数字</p><p>\d  表示数字  \D  非数字</p><h2 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h2><p><img alt="image-20200218013825340" data-src="https://cdn.kaiming66.com/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-image-20200218013825340.png" class="lazyload"></p><p><img alt="image-20200218013833728" data-src="https://cdn.kaiming66.com/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-image-20200218013833728.png" class="lazyload"></p><p><img alt="image-20200218013842958" data-src="https://cdn.kaiming66.com/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-image-20200218013842958.png" class="lazyload"></p><h2 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h2><p>匹配中文字符的正则表达式： [\u4e00-\u9fa5]</p><p>匹配双字节字符(包括汉字在内)：[^\x00-\xff]</p><p>匹配空行的正则表达式：\n[\s| ]*\r</p><p>匹配HTML标记的正则表达式：/&lt;(.<em>)&gt;.</em>&lt;/\1&gt;|&lt;(.*) /&gt;/ </p><p>匹配首尾空格的正则表达式：(^\s<em>)|(\s</em>$)</p><p>匹配IP地址的正则表达式：/(\d+).(\d+).(\d+).(\d+)/g //</p><p>匹配Email地址的正则表达式：\w+([-+.]\w+)<em>@\w+([-.]\w+)*.\w+([-.]\w+)</em></p><p>匹配网址URL的正则表达式：[http://(/](<a href="https://blog.csdn.net/)[\w-]+\.)+[\w-]+" target="_blank" rel="noopener">https://blog.csdn.net/)[\w-]+\.)+[\w-]+</a>(/[\w- ./?%&amp;=]*)?</p><p>sql语句：^(select|drop|delete|create|update|insert).*$</p><p>1、非负整数：^\d+$ </p><p>2、正整数：^[0-9]*[1-9][0-9]*$ </p><p>3、非正整数：^((-\d+)|(0+))$ </p><p>4、负整数：^-[0-9]*[1-9][0-9]*$ </p><p>5、整数：^-?\d+$ </p><p>6、非负浮点数：^\d+(.\d+)?$ </p><p>7、正浮点数：^((0-9)+.[0-9]*[1-9][0-9]<em>)|([0-9]*[1-9][0-9]<em>.[0-9]+)|([0-9]\</em>[1-9][0-9]</em>))$ </p><p>8、非正浮点数：^((-\d+.\d+)?)|(0+(.0+)?))$ </p><p>9、负浮点数：^(-((正浮点数正则式)))$ </p><p>10、英文字符串：^[A-Za-z]+$ </p><p>11、英文大写串：^[A-Z]+$ </p><p>12、英文小写串：^[a-z]+$ </p><p>13、英文字符数字串：^[A-Za-z0-9]+$ </p><p>14、英数字加下划线串：^\w+$ </p><p>15、E-mail地址：^[\w-]+(.[\w-]+)*@[\w-]+(.[\w-]+)+$ </p><p>16、URL：^[a-zA-Z]+://(\w+(-\w+)<em>)(.(\w+(-\w+)</em>))<em>(?\s</em>)?$ </p><p>或：^http://[A-Za-z0-9]+.[A-Za-z0-9]+[/=?%-&amp;_~`@[]&#39;:+!]<em>([^&lt;&gt;&quot;&quot;])</em>$</p><p>17、邮政编码：^[1-9]\d{5}$</p><p>18、中文：^[\u0391-\uFFE5]+$</p><p>19、电话号码：^((\d2,3)|(\d{3}-))?(0\d2,3|0\d{2,3}-)?[1-9]\d{6,7}(-\d{1,4})?$</p><p>20、手机号码：^((\d2,3)|(\d{3}-))?13\d{9}$</p><p>21、双字节字符(包括汉字在内)：^\x00-\xff</p><p>22、匹配首尾空格：(^\s<em>)|(\s</em>$)（像vbscript那样的trim函数）</p><p>23、匹配HTML标记：&lt;(.<em>)&gt;.</em>&lt;/\1&gt;|&lt;(.*) /&gt; </p><p>24、匹配空行：\n[\s| ]*\r</p><p>25、提取信息中的网络链接：(h|H)(r|R)(e|E)(f|F) *= *(‘|”)?(\w|\|/|.)+(‘|”| *|&gt;)?</p><p>26、提取信息中的邮件地址：\w+([-+.]\w+)<em>@\w+([-.]\w+)*.\w+([-.]\w+)</em></p><p>27、提取信息中的图片链接：(s|S)(r|R)(c|C) *= *(‘|”)?(\w|\|/|.)+(‘|”| *|&gt;)?</p><p>28、提取信息中的IP地址：(\d+).(\d+).(\d+).(\d+)</p><p>29、提取信息中的中国手机号码：(86)<em>0</em>13\d{9}</p><p>30、提取信息中的中国固定电话号码：(\d3,4|\d{3,4}-|\s)?\d{8}</p><p>31、提取信息中的中国电话号码（包括移动和固定电话）：(\d3,4|\d{3,4}-|\s)?\d{7,14}</p><p>32、提取信息中的中国邮政编码：[1-9]{1}(\d+){5}</p><p>33、提取信息中的浮点数（即小数）：(-?\d*).?\d+</p><p>34、提取信息中的任何数字 ：(-?\d*)(.\d+)? </p><p>35、IP：(\d+).(\d+).(\d+).(\d+)</p><p>36、电话区号：/^0\d{2,3}$/</p><p>37、腾讯QQ号：^[1-9]*[1-9][0-9]*$</p><p>38、帐号(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$</p><p>39、中文、英文、数字及下划线：^[\u4e00-\u9fa5_a-zA-Z0-9]+$</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM--双亲委派机制</title>
      <link href="/2019/12/10/jvm/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/12/10/jvm/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><ul><li>在Java中，有两大类类加载器：引导类（启动类）加载器、自定义类加载器</li><li>也可以分为四小类：引导类加载器、扩展类加载器、系统类加载器、自定义类加载器</li></ul><h2 id="引导类加载器（c-c-）"><a href="#引导类加载器（c-c-）" class="headerlink" title="引导类加载器（c/c++）"></a>引导类加载器（c/c++）</h2><ul><li>底层是由 c、c++ 实现的，在java方法中是获取不到的，是 jvm 虚拟机的一部分</li><li>主要用来加载核心类库 java、javax、sun 开头的包的</li><li>因为他是由 c/c++ 编写的所以不需要继承 ClassLoader</li><li>扩展类、系统类加载器都是由这个加载的</li></ul><h2 id="自定义类加载器（java）"><a href="#自定义类加载器（java）" class="headerlink" title="自定义类加载器（java）"></a>自定义类加载器（java）</h2><h3 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h3><ul><li>间接继承与ClassLoader</li><li>父类加载器为引导类加载器（非继承关系、类似于上下级关系）</li><li>主要加载目录为 jre/lib/ext 文件夹下的 jar包</li><li>如果用户自己写的 jar 包扔到那也会被加载</li></ul><h3 id="系统（应用）类加载器"><a href="#系统（应用）类加载器" class="headerlink" title="系统（应用）类加载器"></a>系统（应用）类加载器</h3><ul><li>间接继承与ClassLoader</li><li>父类加载器为扩展类加载器</li><li>主要加载为当前用户写的类 classpath 路径下的类</li><li>即我们自定义的 java 类都是由系统类加载器加载的</li></ul><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><ul><li>这个就是我们继承 ClassLoader 类，重写他的 loadClass 方法或者 findClass 方法所实现的加载器</li><li>我们可以复杂的实现，自己处理二进制字节码流，自定义加密解密了</li><li>或者简单实现直接继承 URLClassLoader 不用处理字节码流</li></ul><h2 id="为什么要自定义加载器"><a href="#为什么要自定义加载器" class="headerlink" title="为什么要自定义加载器"></a>为什么要自定义加载器</h2><ol><li>隔离加载类：框架中用的比较多，以避免类路径一直而冲突</li><li>修改类加载方式</li><li>扩展加载源</li><li>防止源码泄漏：加密解密</li></ol><h2 id="双亲委派机制-1"><a href="#双亲委派机制-1" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p><img alt="image-20200211200530592" data-src="https://cdn.kaiming66.com/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD--image-20200211200530592.png" class="lazyload"></p><p>机制原理：</p><p>​    一个类加载器收到了类加载的请求时，他并不会直接先去自己加载，而是委托给父类加载器来执行，如果父类加载器还有父类则递归直到顶层加载器。如果已经加载则不用加载，若加载未成功，这时才会自己尝试去加载，我们看一下 loadClass 源码更容易理解这一过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">//首先查看该类是否已经被加载过</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//如果父级不为空则交给父级去处理</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//如果父级为空那么证明父级就是引导类加载器了，交给他去处理</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                   </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果还找不到则自己去尝试加载</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="反向委派机制"><a href="#反向委派机制" class="headerlink" title="反向委派机制"></a>反向委派机制</h3><p>​        这里也是个小知识点，在我们调用第三方方法时，我们的核心类库是没有这些类的，比如 jdbc，我们的引导类加载器会去加载这个接口，但是这个接口的实现类，就会通过反向委派的机制交给<strong>线程上下文类加载器</strong>，（本质上就是系统类加载器），让他去加载这个接口的实现类</p><p><img alt="image-20200211203647264" data-src="https://cdn.kaiming66.com/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD--image-20200211203647264.png" class="lazyload"></p><h2 id="双亲委派机制的好处"><a href="#双亲委派机制的好处" class="headerlink" title="双亲委派机制的好处"></a>双亲委派机制的好处</h2><p>假如我们自己写个 String 类，包名都起的一样：</p><p><img alt="image-20200211202759590" data-src="https://cdn.kaiming66.com/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD--image-20200211202759590.png" class="lazyload"></p><p>这样的话执行 main 方法会怎么样？</p><p><img alt="image-20200211202824730" data-src="https://cdn.kaiming66.com/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD--image-20200211202824730.png" class="lazyload"></p><p>肯定会报错，因为双亲委派的机制，我们的 String 属于核心 API 所以会在引导类加载器处直接加载了，那么 String 类里怎么可能有 main 方法呢，所以会出现错误</p><p>那么好处就显而易见了。</p><ul><li>避免类被重复加载</li><li>保护程序安全，防止核心 API 被篡改（也成为沙箱安全机制）</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>如何判断两个 Class 对象是一样的</p><ul><li>类的完整类名必须一致，包括包名</li><li>加载这个类的 ClassLoader 类，必须相同</li></ul><p>jvm 必须知道一个类型是由引导类加载器加载的还是用户类加载器加载的</p><p><strong>如果一个类是由用户类加载器加载的，那么 jvm 会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。</strong></p><p>类的主动使用和被动使用：</p><ul><li>不会导致类的初始化，叫做的类的被动使用</li></ul>]]></content>
      
      
      <categories>
          
          <category> Jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM--查看GC日志</title>
      <link href="/2019/12/09/jvm/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--%E6%9F%A5%E7%9C%8BGC%E6%97%A5%E5%BF%97/"/>
      <url>/2019/12/09/jvm/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--%E6%9F%A5%E7%9C%8BGC%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="查看-GC-日志"><a href="#查看-GC-日志" class="headerlink" title="查看 GC 日志"></a>查看 GC 日志</h1><h2 id="设置-vm-参数"><a href="#设置-vm-参数" class="headerlink" title="设置 vm 参数"></a>设置 vm 参数</h2><p>在Run/Debug configurations 的VM options文本框中输入：<code>-XX:+PrintGCDateStamps -XX:+PrintGCDetails</code></p><h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB =  <span class="number">1024</span> *<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GCTest objA = <span class="keyword">new</span> GCTest();</span><br><span class="line">        GCTest objB = <span class="keyword">new</span> GCTest();</span><br><span class="line"></span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA=<span class="keyword">null</span>;</span><br><span class="line">        objB=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GC-日志"><a href="#GC-日志" class="headerlink" title="GC 日志"></a>GC 日志</h2><p><img alt="image-20200216232050142" data-src="https://cdn.kaiming66.com/jvmGC%E6%97%A5%E5%BF%97-image-20200216232050142.png" class="lazyload"></p><h2 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h2><ol><li>PSYoungGen：表示新生代，这个名称由收集器决定。PS是Parallel Scavenge收集器的缩写，新生代又分化 eden space、from space和to space这三部分</li><li>ParOldGen：Parallel Scavenge收集器配套的老年代</li><li>Metaspace： Parallel Scavenge收集器配套的永久代，JDK 1.8 移除了永久代，取而代之的是 Metaspace（元空间）</li><li>total &amp; used：总的空间和用掉的空间</li></ol><p>第一行的 GC （System.gc()）代表的这次 GC 是 Minor GC，原因是调用了 System.gc() 的方法。如果是因为新生代空间不足那么括号里应该为 Allocation Failure </p><p>[PSYoungGen 8032K -&gt;808K (76288K)] 方块里面的表示 新生代是由 Parallel Scavenge 收集器收集的.</p><ul><li>8032 K：是指新生代回收前该内存使用容量</li><li>808 K：是指新生代回收后该内存使用容量</li><li>76288 K：是指新生代总的容量大小</li></ul><p>在方块外边的就是 Java 堆了</p><p>Times：user是用户态耗费的时间，sys是内核态耗费的时间，real是整个过程实际花费的时间一般优化看的是 real 时间。</p><p>Full GC 就是 Major GC，即老年代 GC ，参数同理。</p>]]></content>
      
      
      <categories>
          
          <category> Jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM--JVM常用命令</title>
      <link href="/2019/12/08/jvm/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--JVM%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/12/08/jvm/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--JVM%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM虚拟机常用命令参数"><a href="#JVM虚拟机常用命令参数" class="headerlink" title="JVM虚拟机常用命令参数"></a>JVM虚拟机常用命令参数</h1><h2 id="初始堆大小"><a href="#初始堆大小" class="headerlink" title="初始堆大小"></a>初始堆大小</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如 -Xms256m</span></span><br><span class="line">-Xms</span><br></pre></td></tr></table></figure><h2 id="最大堆大小"><a href="#最大堆大小" class="headerlink" title="最大堆大小"></a>最大堆大小</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如 -Xmx512m</span></span><br><span class="line">-Xmx</span><br></pre></td></tr></table></figure><h2 id="栈大小"><a href="#栈大小" class="headerlink" title="栈大小"></a>栈大小</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK1.5+ 每个线程堆栈大小为 1M，一般来说如果栈不是很深的话， 1M 是绝对够用了的。</span></span><br><span class="line">-Xss</span><br></pre></td></tr></table></figure><h2 id="新生代老年代比例"><a href="#新生代老年代比例" class="headerlink" title="新生代老年代比例"></a>新生代老年代比例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如 –XX:NewRatio=2，则新生代占整个堆空间的1/3，老年代占2/3</span></span><br><span class="line">-XX:NewRatio</span><br></pre></td></tr></table></figure><h2 id="Eden区与-Survivor区比值"><a href="#Eden区与-Survivor区比值" class="headerlink" title="Eden区与 Survivor区比值"></a>Eden区与 Survivor区比值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认值为 8。即 Eden 占新生代空间的 8/10，另外两个 Survivor 各占 1/10 </span></span><br><span class="line">-XX:SurvivorRatio</span><br></pre></td></tr></table></figure><h2 id="新生代空间"><a href="#新生代空间" class="headerlink" title="新生代空间"></a>新生代空间</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新生代大小。通常为 Xmx 的 1/3 或 1/4</span></span><br><span class="line">-Xmn</span><br></pre></td></tr></table></figure><h2 id="方法区大小"><a href="#方法区大小" class="headerlink" title="方法区大小"></a>方法区大小</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//永久代(方法区)的初始大小</span></span><br><span class="line">-XX:PermSize</span><br></pre></td></tr></table></figure><h2 id="方法区最大大小"><a href="#方法区最大大小" class="headerlink" title="方法区最大大小"></a>方法区最大大小</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//永久代(方法区)的最大值</span></span><br><span class="line">-XX:MaxPermSize</span><br></pre></td></tr></table></figure><h2 id="打印-GC-日志"><a href="#打印-GC-日志" class="headerlink" title="打印 GC 日志"></a>打印 GC 日志</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虚拟机参数</span></span><br><span class="line">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><h2 id="dump内存溢出快照"><a href="#dump内存溢出快照" class="headerlink" title="dump内存溢出快照"></a>dump内存溢出快照</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//让虚拟机在发生内存溢出时 Dump 出当前的内存堆转储快照，以便分析用</span></span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br></pre></td></tr></table></figure><h2 id="老年代年龄阈值"><a href="#老年代年龄阈值" class="headerlink" title="老年代年龄阈值"></a>老年代年龄阈值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虚拟机参数</span></span><br><span class="line">-XX:MaxTenuringThreshold</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM--垃圾回收机制</title>
      <link href="/2019/12/08/jvm/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/12/08/jvm/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><blockquote><p>总结自 周志明的《深入理解 Java 虚拟机》</p></blockquote><h2 id="抛出问题，带着问题去学习"><a href="#抛出问题，带着问题去学习" class="headerlink" title="抛出问题，带着问题去学习"></a>抛出问题，带着问题去学习</h2><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>怎么回收？</li></ul><h2 id="如何判断对象是否死亡"><a href="#如何判断对象是否死亡" class="headerlink" title="如何判断对象是否死亡"></a>如何判断对象是否死亡</h2><h3 id="引用计数器"><a href="#引用计数器" class="headerlink" title="引用计数器"></a>引用计数器</h3><p>​        给对象加一个引用计数器，每有一个地方引用它时，那么计数器就 +1 ，当引用失效时就 -1 ，如果等于 0 的话这个对象就不可能再被引用了，即判断对象死亡。</p><p>优点：实现简单，判定效率也很高</p><p>缺点：没有办法解决循环引用的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//为了占内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB =  <span class="number">1024</span> *<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GCTest objA = <span class="keyword">new</span> GCTest();</span><br><span class="line">        GCTest objB = <span class="keyword">new</span> GCTest();</span><br><span class="line">    <span class="comment">//循环引用</span></span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA=<span class="keyword">null</span>;</span><br><span class="line">        objB=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        在这种情况下，虽然 objA、objB 都等于 null 了，实际上这两个对象不可能访问到了，但是他们之间还是互相引用着，所以计数器无法通知 GC 收集器去回收他们。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>​        现在主流的回收机制都是用可达性分析来判定对象是否存活的。</p><p>​        从 GCROOTS 开始，从这些结点开始向下搜索，所走过的路径称为引用链，当一个对象到 GCROOTS 没有任何引用链的时候，那么就说明这个对象是不可用的，判定为可回收对象。</p><p>可作为 GCROOTS 的对象包括下面几种：</p><ol><li>虚拟机栈（栈帧中的本地变量表）中的引用对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中的JNI（Java Native Interface）引用的对象</li></ol><h2 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h2><blockquote><p>JDK 1.2 之前的引用很传统，reference 类型的数据就是另外一块内存的起始地址，JDK 1.2 之后对引用的概念进行了扩展：强引用、软引用、弱引用、虚引用</p></blockquote><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>​        在程序中很普遍，类似 “Object obj = new Object()” ，只要强引用还在，GC 就永远不会回收它，宁肯抛出 OOM ，也不会来回收强引用类型的对象</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>​        用来描述还有用但非必需的对象。也就是说内存足够的情况下，GC 不会回收它，程序还可以照常使用。但是如果出现内存不足的情况，那么 GC 就会回收它，如果还不够才会抛出 OOM 异常，softReference 类实现软引用</p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>​        也是类似软引用一样有用但非必需的，即可有可无的。但是引用的强度会比软引用要低一些，被弱引用引用的对象只能存活到发生下一次垃圾回收之前。当 GC 开始回收时，不管内存是否充足都会回收掉被关联的对象，weakReference。</p><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>​        又称幽灵引用和幻影引用，是最弱的一种引用，他与软引用和弱引用的区别就是它必须和引用队列联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>​        引用的使用，弱引用和虚引用的使用很少，软引用也比较多，因为<strong>软引用可以加速JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。</strong></p><h2 id="不可达对象并非“非死不可”"><a href="#不可达对象并非“非死不可”" class="headerlink" title="不可达对象并非“非死不可”"></a>不可达对象并非“非死不可”</h2><p>​        JVM 虚拟机判断一个对象死亡时，至少要经过两次标记的过程：</p><p>​        如果对象在进行可达性分析后发现无与 GCROOTS 相连的引用链，那么这时会被第一次标记，并进行一次筛选：筛选的条件是是否有必要执行 finalize() 方法，如果对象没有覆盖 finalize() 方法，或者已经被调用过一次这个方法，那么都没必要执行 finalize() 方法。<strong>即一个对象的 finalize() 方法，只会执行一次</strong></p><p>​        如果有必要执行，那么就会进入一个队列，在这个队列里执行 finalize() 方法，finalize() 方法是对象逃脱死亡的最后一次机会，如果对象自救成功，那么在虚拟机对队列进行二次标记的时候就会被拿出来，剩下的就会被回收。</p><h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><h3 id="如何判断一个常量是废弃常量"><a href="#如何判断一个常量是废弃常量" class="headerlink" title="如何判断一个常量是废弃常量"></a>如何判断一个常量是废弃常量</h3><p>运行时常量池主要回收的是废弃的常量。</p><p>​        假如在常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。</p><p><strong>（重点补充）</strong></p><p>JDK 1.7 后的版本把运行时常量池从方法区中移出来了，Java 堆（Heap）中开辟了一块空间存放运行时常量池。</p><p>JDK 1.8 移除整个永久代，取而代之的是叫元空间的区域。</p><h3 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a>如何判断一个类是无用的类</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法（后续算法的基础）"><a href="#标记-清除算法（后续算法的基础）" class="headerlink" title="标记-清除算法（后续算法的基础）"></a>标记-清除算法（后续算法的基础）</h3><p><img alt="image-20200216152741394" data-src="https://cdn.kaiming66.com/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-image-20200216152741394.png" class="lazyload"></p><p>​        该算法分为两个阶段：先标记、后清除。作为最基础的算法有两个问题：</p><ol><li><p>效率问题</p></li><li><p>垃圾回收后空间问题（会产生大量的内存碎片）</p><p>大量的内存碎片可能导致，后来要分配比较大的对象时，会因为内存空间不足而在此触发 GC 动作。</p></li></ol><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p><img alt="image-20200216152754029" data-src="https://cdn.kaiming66.com/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-image-20200216152754029.png" class="lazyload"></p><p>​        把可用的内存空间分为大小相同的两块，当一块空调用完时，就将还存活的对象复制到另一边的内存上，然后再将已使用过的内存空间全部清理掉。这样每次只针对一般的空间进行回收，也不会产生内存碎片的情况。</p><p>​        主流的虚拟机都采用这种算法来处理新生代。新生代的对象 98% 都是朝生暮死的，所以将新生代的内存布局分配为 Eden区、From Survivor区、To Survivor区，大小为 8:1:1 ，对象优先在 Eden 区上分配</p><p><img alt="image-20200216165622871" data-src="https://cdn.kaiming66.com/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-image-20200216165622871.png" class="lazyload"></p><p>​        上图的 eden、s0(From)、s1(To)区都属于新生代，tentired 区属于老年代。大部分情况都是直接在 eden 上直接分配，在新生代回收过一次后，如果仍有对象存活这时候会进入 s1(To)，并且对象的年龄会 +1 ，当它的年龄到达一定程度的时候（默认是 15 岁，年龄的阈值可以通过 JVM 参数设置），就会被放到老年代。如果存活的对象大于 To Survivor 区的大小，那么就会通过分配担保机制将这些对象放入老年代。而分配完后，会将 to 和 from 对换一直保证 To的空间是空闲的，因此会有 10% 空间的浪费。Minor GC会一直重复这样的过程，直到“To”区被填满，”To”区被填满之后，会将所有对象移动到老年代中。</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p><img alt="image-20200216171346730" data-src="https://cdn.kaiming66.com/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-image-20200216171346730.png" class="lazyload"></p><p>​        复制收集算法在对象存活率较高的情况下，效率就会比较低下。如果发生这种存活率 100% 的情况，那么复制算法显然是不适合的而且还会占用大量的空间，所以在老年代中不能采取这样的算法。</p><p>​        所以根据老年代的特点，有一种标记-整理算法，它与标记-清除算法很像，但是标记完后不是直接删除，而是将所有存活的对象向一端移动，然后清理掉端边界以外的内存。</p><h3 id="分代-收集算法"><a href="#分代-收集算法" class="headerlink" title="分代-收集算法"></a>分代-收集算法</h3><ul><li>新生代：存活率低–复制算法</li><li>老年代：存活率高–标记-清除算法、标记-整理算法</li></ul><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p><img alt="image-20200216172932199" data-src="https://cdn.kaiming66.com/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-image-20200216172932199.png" class="lazyload"></p><p>​        是最基本、发展历史最悠久的收集器。Serial（串行）看名字就知道是单线程收集器。不过这里的 “单线程” 的意义不仅仅意味着它只会用一条垃圾收集线程去完成收集工作，而且在它工作收集的时候，还必须暂停用户当前的所有线程，直至它工作结束</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong>用在 client 模式下的虚拟机上会不错。</p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p><img alt="image-20200216173057845" data-src="https://cdn.kaiming66.com/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-image-20200216173057845.png" class="lazyload"></p><p>​        ParNew 收集器其实就是 Serial 收集器的多线程版本，实际实现上也公用了许多代码。支持多个垃圾收集线程去执行收集任务，但是还是会暂停用户线程。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong>运行在 Server 模式下的虚拟机的首选</p><p>除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p><p><strong>并行和并发概念补充：</strong></p><ul><li><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</li></ul><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p><img alt="image-20200216173057845" data-src="https://cdn.kaiming66.com/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-image-20200216173057845.png" class="lazyload"></p><p>​        它与 ParNew 收集器几乎一模一样，都是多线程收集器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JVM 参数：</span><br><span class="line">-XX:+UseParallelGC </span><br><span class="line">    <span class="comment">//使用 Parallel 收集器+ 老年代串行</span></span><br><span class="line">-XX:+UseParallelOldGC</span><br><span class="line">    <span class="comment">//使用 Parallel 收集器+ 老年代并行</span></span><br></pre></td></tr></table></figure><p>Parallel Scavenge 收集器关注的是吞吐量（高效的利用cpu），而 CMS 等垃圾收集器注重的是用户线程的停顿时间（提高用户体验），吞吐量就是 cpu 中用于用户运行代码的时间和 cpu 的总运行时间的比值。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><h3 id="Serial-old-收集器"><a href="#Serial-old-收集器" class="headerlink" title="Serial old 收集器"></a>Serial old 收集器</h3><p>​        见名知义，Serial 的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><h3 id="Parallel-old-收集器"><a href="#Parallel-old-收集器" class="headerlink" title="Parallel old 收集器"></a>Parallel old 收集器</h3><p>​        一样是 Parallel Scavenge 收集器的老年代版本。标记-整理算法</p><h3 id="CMS-收集器（Concurrent-Mark-Sweep）"><a href="#CMS-收集器（Concurrent-Mark-Sweep）" class="headerlink" title="CMS 收集器（Concurrent Mark Sweep）"></a>CMS 收集器（<strong>Concurrent Mark Sweep</strong>）</h3><p>​        CMS 收集器以最短停顿时间为目标，注重用户的使用体验。</p><p>​        CMS 收集器是第一个真正意义上的并发收集器，<strong>它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>​        从名字可以看出 Mark Sweep 使用的是标记-清除算法，实现也更加复杂，整个过程分为四部分：</p><ol><li><strong>初始标记</strong>：暂停所有其他的线程，并记录下直接与 root连接的对象，速度很快</li><li><strong>并发标记</strong>：同时开启 GC 线程和用户线程，用一个闭包结构记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以无法保证实时性，所以这个算法会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记</strong>：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对为标记的区域做清扫。</li></ol><p><img alt="image-20200216212725837" data-src="https://cdn.kaiming66.com/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-image-20200216212725837.png" class="lazyload"></p><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><p>​        G1 收集器是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征。</p><p>​        hotspot 团队想让它将来替代 CMS 收集器</p><p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记–清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong>。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 GF 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><p><img alt="image-20200216212725837" data-src="https://cdn.kaiming66.com/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83.jpg" class="lazyload"></p><p>​        对象优先在 eden 区上分配，如果 eden 区的空间不足以分配，那么虚拟机将发起一次 Minor GC </p><ul><li><strong>新生代 GC（Minor GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</li><li><strong>老年代 GC（Major GC/Full GC）</strong>:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</li></ul><p>​        大对象会直接分配在老年代（比如：数组、字符串），为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p><p>​        长期存活的对象也会进入老年代，默认年龄 15 进入，但是虚拟机有动态对象年龄判定如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需达到要求的年龄。</p><h2 id="打印-GC-日志"><a href="#打印-GC-日志" class="headerlink" title="打印 GC 日志"></a>打印 GC 日志</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虚拟机参数</span></span><br><span class="line">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><h2 id="老年代年龄阈值"><a href="#老年代年龄阈值" class="headerlink" title="老年代年龄阈值"></a>老年代年龄阈值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虚拟机参数</span></span><br><span class="line">-XX:MaxTenuringThreshold</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正确使用 equals() 方法</title>
      <link href="/2019/12/06/Java/%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%20equals()%20%E6%96%B9%E6%B3%95/"/>
      <url>/2019/12/06/Java/%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%20equals()%20%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="正确使用-equals-方法"><a href="#正确使用-equals-方法" class="headerlink" title="正确使用 equals() 方法"></a>正确使用 equals() 方法</h1><p>Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常</span></span><br><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (str.equals(<span class="string">"SnailClimb"</span>)) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面的程序会抛出空指针异常，但是我们把第二行的条件判断语句改为下面这样的话，就不会抛出空指针异常，else 语句块得到执行。：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"SnailClimb"</span>.equals(str);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>解释 ：</p><p>​        equals 产生空指针的原因就是，值为 null 的引用变量去调用非静态方法。</p><p>JDK 1.7 引入了 java.util.Objects 工具类，我们可以调用它的 equals() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Objects.equals(<span class="keyword">null</span>,<span class="string">"SnailClimb"</span>);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>我们看一下 Objects 的 equals 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以避免空指针异常。如果a==null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。</span></span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归根结底就是不让 null 来调用方法</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整型包装类之间的比较</title>
      <link href="/2019/12/06/Java/%E6%95%B4%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E6%AF%94%E8%BE%83/"/>
      <url>/2019/12/06/Java/%E6%95%B4%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h1 id="整型包装类之间的比较"><a href="#整型包装类之间的比较" class="headerlink" title="整型包装类之间的比较"></a>整型包装类之间的比较</h1><h2 id="所有整型包装类对象值的比较必须使用-equals-方法"><a href="#所有整型包装类对象值的比较必须使用-equals-方法" class="headerlink" title="所有整型包装类对象值的比较必须使用 equals 方法"></a>所有整型包装类对象值的比较必须使用 equals 方法</h2><p>先看下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="number">3</span>;</span><br><span class="line">Integer y = <span class="number">3</span>;</span><br><span class="line">System.out.println(x == y);<span class="comment">// true</span></span><br><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">Integer b = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">System.out.println(a == b);<span class="comment">//false</span></span><br><span class="line">System.out.println(a.equals(b));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>解释：</p><p>​        当使用自动装箱方式创建一个Integer对象时，当数值在-128 ~127时，会将创建的 Integer 对象缓存起来，当下次再出现该数值时，直接从缓存中取出对应的Integer对象。所以上述代码中，x和y引用的是相同的Integer对象。</p><p>​        这个跟 String 类型就有点类似了，但不完全一样，而且 Integer 是有范围的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM--内存区域总结</title>
      <link href="/2019/12/06/jvm/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E6%80%BB%E7%BB%93/"/>
      <url>/2019/12/06/jvm/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-虚拟机内存区域总结"><a href="#Java-虚拟机内存区域总结" class="headerlink" title="Java 虚拟机内存区域总结"></a>Java 虚拟机内存区域总结</h1><blockquote><p>总结自 周志明 的《深入理解 Java 虚拟机》</p></blockquote><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>​        Java 和 c++ 比，他的内存在虚拟机的自动管理下确实香，但是如果这样出现内存泄漏或者溢出可能就没那么香了，为此我们就需要了解一下 Java 虚拟机的内存区域</p><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><blockquote><p>根据《Java 虚拟机规范(Java SE 7 版)》规定，Java 虚拟机所管理的内存如下图所示。</p></blockquote><p><img alt="img" data-src="https://cdn.kaiming66.com/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%281%29.jpg" class="lazyload"></p><h2 id="程序计数器（线程私有）"><a href="#程序计数器（线程私有）" class="headerlink" title="程序计数器（线程私有）"></a>程序计数器（线程私有）</h2><p>​        唯一一个在 Java 虚拟机中没有规定任何 OutOfMemoryError 情况的区域。</p><p>​        它可以看作是当前线程所执行的字节码的行号的指示器，字节码解释器工作的时候就是靠这个来指定吓一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复都是靠这个来完成的。</p><p>​        对于多线程在一个处理器上执行，那么就会轮流切换来获取处理器的执行时间，那么想要线程之间切换并恢复到正确的位置，那么所以计数器就是<strong>线程私有</strong>的！</p><ul><li>如果线程正在执行的是 <strong>Java</strong> 方法，那么计数器记录正在执行的字节码指令的地址</li><li>如果线程正在执行的是 <strong>Native</strong> 方法，那么计数器的值为 空（Undefined）</li></ul><h2 id="Java-虚拟机栈（线程私有）"><a href="#Java-虚拟机栈（线程私有）" class="headerlink" title="Java 虚拟机栈（线程私有）"></a>Java 虚拟机栈（线程私有）</h2><p>​        因为也是线程私有的，所以生命周期与线程相同。</p><p>​        每个方法执行的时候都会创建一个 栈帧 用于存储：局部变量表、操作数栈、动态链接、方法出口 等信息。</p><p>​        每一个方法的调用和执行完成就对应着，每一个栈帧在虚拟机栈中的入栈和出栈</p><p>​        局部变量表：存放了各种编译器可知的基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型）和 returnAddress 类型（指向了一条字节码指令的地址）</p><p>溢出异常：</p><ul><li>StackOverflowError：请求的栈的深度大于虚拟机所允许的深度</li><li>OutOfMemoryError：动态扩展时无法申请到足够的内存报错</li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>​        其实和 Java 虚拟机栈作用非常相似，唯一区别就是 Java 虚拟机栈为 Java 方法服务，本地方法栈为 Native 方法服务，也有那两种溢出异常。</p><h2 id="Java-堆（线程共享、GC堆）"><a href="#Java-堆（线程共享、GC堆）" class="headerlink" title="Java 堆（线程共享、GC堆）"></a>Java 堆（线程共享、GC堆）</h2><p>​        Java 内存管理中最大的一块了，Java 堆是所有线程共享的内存区域，在虚拟机创建时启动。</p><p>​        只有一个目的：<strong>存放 Java 的对象实例</strong></p><p>​        所有对象和数组都要在 堆 上分配，不过随着 JIT 的发展没有那么绝对了。</p><p>​        Java 堆是垃圾处理器管理的主要区域了，所以别名就叫 GC 堆 。Java 堆中可以分为：新生代、老年代，更细致一点就是：Eden 空间、From Survivor 空间、To Survivor 空间。</p><p>​        这里可能还会有个多线程私有的分配缓冲区，作用无疑就是加快内存的回收和分配。</p><p>​        Java 堆的内存物理地址可以不连续，但是逻辑上是连续的</p><p>溢出异常：</p><ul><li>OutOfMemoryError：在内存无法完成实例分配，Java 堆无法扩展的时候报错。</li></ul><h2 id="方法区（线程共享、永久代）"><a href="#方法区（线程共享、永久代）" class="headerlink" title="方法区（线程共享、永久代）"></a>方法区（线程共享、永久代）</h2><p>​        方法区和 Java 堆一样都是线程共享的，这里主要存放：类信息、常量、静态变量、已经编译好的代码。</p><p>​        JDK 1.7 版本将 字符串常量池 移出了 永久代</p><p>溢出异常：</p><ul><li>OutOfMemoryError：当方法区无法满足内存分配需求的时候报错</li></ul><h2 id="一张图总结一哈"><a href="#一张图总结一哈" class="headerlink" title="一张图总结一哈"></a>一张图总结一哈</h2><p><img alt="img" data-src="https://cdn.kaiming66.com/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%282%29.jpg" class="lazyload"></p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>​        运行时常量池 是 方法区 的一部分！！</p><p>​        里面存放着：Class 文件编译期生成的 各种字面量和符号引用，在类加载时进入运行时常量池</p><p>​        编译器和运行期（String的intern()方法）都能将常量放入</p><p>溢出异常：</p><ul><li>既然是方法区的一部分那么一样，OutOfMemoryError：无法申请时报错</li></ul><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>​        并不属于虚拟机规范中定义的内存区域，但是这部分内存也经常使用，可能会导致 OutOfMemoryError 异常的出现。</p><p>​        在 JDK 1.4 中新加入 NIO (New Input/Output) 类，引入了一种基于通道(Channel)和缓存(Buffer)的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。可以避免在 Java 堆和 Native 堆中来回的数据耗时操作。</p><p>溢出异常：</p><ul><li>OutOfMemoryError：会受到本机内存限制，如果内存区域总和大于物理内存限制从而导致动态扩展时出现该异常。</li></ul><p>（图片来自大佬博客：<a href="https://blog.csdn.net/qq_41701956/article/details/81664921" target="_blank" rel="noopener">Java虚拟机（JVM）你只要看这一篇就够了！</a>,有一说一，这博客写的确实好推荐去看）</p><hr>]]></content>
      
      
      <categories>
          
          <category> Jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 面试（一）– 基础知识总结</title>
      <link href="/2019/12/05/Java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/2019/12/05/Java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-面试（一）–-基础知识总结"><a href="#Java-面试（一）–-基础知识总结" class="headerlink" title="Java 面试（一）– 基础知识总结"></a>Java 面试（一）– 基础知识总结</h1><blockquote><p>本文根据 Java Guide</p></blockquote><h2 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h2><ul><li>面向对象的性能比面向过程的性能低<ul><li>因为类调用得初始化、实例化，比较消耗资源</li><li>Java是半编译语言，最终的执行代码并不是可以直接被CPU执行的二进制机械码，而是交由jvm处理。</li></ul></li></ul><h2 id="Java-语言有哪些特点？"><a href="#Java-语言有哪些特点？" class="headerlink" title="Java 语言有哪些特点？"></a>Java 语言有哪些特点？</h2><ul><li>Java 三大特性（封装、继承、多态）</li><li>jvm 实现跨平台特性</li><li>支持多线程和网络编程</li><li>编译和解释并存<ul><li><strong>编译器</strong>是把源程序的每一条语句都编译成机器语言,并保存成二进制文件,这样运行时计算机可以直接以机器语言来运行此程序,速度很快; </li><li>而<strong>解释器</strong>则是只在执行程序时,才一条一条的解释成机器语言给计算机来执行,所以运行速度是不如编译后的程序运行的快的. </li><li>Java 比较特殊是先编译成字节码（.class）文件并不是其他语言编译后的二进制文件，然后在 jvm 上解释执行字节码。</li></ul></li></ul><p><img alt="image-20191205000632350" data-src="https://cdn.kaiming66.com/image-20191204232024421.png" class="lazyload"></p><ul><li>.class 字节码 –&gt; 机器码，jvm 逐行解释会比较慢，所以引入了 JIT 编译器，JIT 完成一次编译后会将字节码对应的机器码保留下来，jvm 会根据每次执行的情况收集信息进行优化，所以越执行越快。</li><li>jvm 是实现 “一次编译，到处运行”的关键</li></ul><h2 id="jdk、jre、jvm-的关系"><a href="#jdk、jre、jvm-的关系" class="headerlink" title="jdk、jre、jvm 的关系"></a>jdk、jre、jvm 的关系</h2><ul><li>jdk 包括：<ul><li>javac（编译器）</li><li>javadoc（生成java文档）</li><li>jdb（命令行下debug）</li><li>jre 包括：<ul><li>jvm</li><li>java类库</li></ul></li></ul></li><li>javadoc 图例：</li></ul><p><img alt="image-20191205001016598" data-src="https://cdn.kaiming66.com/image-20191205001016598.png" class="lazyload"></p><p><img alt="image-20191205001020328" data-src="https://cdn.kaiming66.com/image-20191205001020328.png" class="lazyload"></p><ul><li>如果你只想运行 java 程序的话 jre 就够了，但是基本上还是得需要 jdk</li><li>HotSpot VM 是 Oracle JDK 和 Open JDK 共同的虚拟机，即 jvm </li><li>Oracle JDK 基于 Open JDK，但是更稳定，性能更好</li></ul><h2 id="Java-与-c-的区别于联系"><a href="#Java-与-c-的区别于联系" class="headerlink" title="Java 与 c++ 的区别于联系"></a>Java 与 c++ 的区别于联系</h2><ul><li>都是面向对象，封装、继承、多态</li><li>Java 不提供指针访问内存，内存更安全</li><li>Java 类是单继承，c++可以多继承</li><li>Java 有内存自动管理机制，无需手动释放内存</li></ul><h2 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a>字符型常量和字符串常量的区别</h2><ul><li>形式上：<ul><li>char ：单引号引起来的一个字符</li><li>string：双引号引起的多个字符</li></ul></li><li>含义：<ul><li>char：字符型常量相当于一个整型值（ASCII值）</li><li>string：代表一个地址值（即该字符串在内存中的位置）</li></ul></li><li>占内存大小：<ul><li>char：2字节</li><li>string：最少一字符（结束标志）</li></ul></li></ul><p><img alt="image-20191205001256271" data-src="https://cdn.kaiming66.com/image-20191205001256271.png" class="lazyload"></p><h2 id="构造器-Constructor-不能被-override"><a href="#构造器-Constructor-不能被-override" class="headerlink" title="构造器 Constructor 不能被 override"></a><strong>构造器 Constructor 不能被 override</strong></h2><h2 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h2><ul><li>重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</li><li>重写： 父类方法访问修饰符为 private 则子类就不能重写该方法。<strong>也就是说方法提供的行为改变，而方法的外貌并没有改变。</strong></li></ul><h2 id="Java-面向对象三大特性：封装、继承、多态"><a href="#Java-面向对象三大特性：封装、继承、多态" class="headerlink" title="Java 面向对象三大特性：封装、继承、多态"></a>Java 面向对象三大特性：封装、继承、多态</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>继承： <strong>继承是使用已存在的类的定义作为基础建立新类的技术，</strong> <strong>通过使用继承我们能够非常方便地复用以前的代码</strong>。子类用父类的功能或者自己增加新的功能，<strong>但不能选择性的继承。</strong><ul><li><strong>1.</strong>子类拥有父类的所有方法和属性<strong>（包括私有属性和方法）</strong>，但是无法访问，只是拥有</li><li>2.子类可以有自己的属性和方法，即可以对父类扩展</li><li>3.子类可以用自己的方式实现父类的方法（重写）</li><li>解释：<ul><li>子类继承父类，子类拥有父类所有的属性和方法，但是父类的私有属性和私有方法，子类是不能访问的，当然一些父类的<strong>私有属性可能可以通过相应的方法访问到，但是私有的方法似乎不能简单的访问</strong>，这里暂不考虑Java反射机制。<strong>在一个子类被创建的时候，首先会在内存中创建一个父类对象，然后在父类对象外部放上子类独有的属性，两者合起来形成一个子类的对象。</strong>子类对象确实拥有父类对象中所有的属性和方法，但是父类对象中的私有属性和方法，子类是无法访问到的，只是拥有，但不能使用。所以子类对象是绝对大于父类对象的，所谓的子类对象只能继承父类非私有的属性及方法的说法是错误的，可以继承，只是无法访问到而已</li></ul></li></ul></li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul><li>封装：把这个对象的属性私有化，然后对外提供可以被外界访问属性的方法。</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul><li><strong>多态</strong>： 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。<br>就是在编程期间，并不知道这个引用变量指向的具体类型是什么，或者是方法该调用哪个，只有在程序运行期间才能确定。多态的两种实现方式：<ul><li>继承（多个子类对一个方法的重写）</li><li>实现接口（实现接口并覆盖同一方法）</li></ul></li></ul><h2 id="String、StringBuffer、StringBuilder-的区别？为什么String-是不可变的？"><a href="#String、StringBuffer、StringBuilder-的区别？为什么String-是不可变的？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？为什么String 是不可变的？"></a>String、StringBuffer、StringBuilder 的区别？为什么String 是不可变的？</h2><ul><li>String 源码中，用 <strong>private final char value[]</strong> 保存字符，因为 final 所以是不可变的</li><li>StringBuffer 和 StringBuilder 都是继承 AbstractStringBuilder 类，而在这个类中 <strong>char value[]</strong> 保存字符，所以这两个可以改变</li><li>StringBuffer 和 StringBuilder 都是调用者 AbstractStringBuilder 的构造函数：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123; </span><br><span class="line">        <span class="keyword">char</span>[] value; </span><br><span class="line">        <span class="keyword">int</span> count; </span><br><span class="line">        AbstractStringBuilder() &#123; </span><br><span class="line">        &#125; </span><br><span class="line">        AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">            value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity]; </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>线程安全性：<ul><li>String 中的对象是不可变的，可以理解为常量，所以线程安全</li><li>AbstractStringBuilder 是这俩的公共父类，定义了一些对字符串操作的方法<ul><li>StringBuffer 对方法加了同步锁，所以线程安全</li><li>StringBuilder 并没有加锁，所以非线程安全</li></ul></li><li>性能：<ul><li>String 每次改变时都会生成一个新的对象，然后指针指向这个新的对象</li><li>StringBuffer 、StringBuilder 都是对自己本身操作，不会产生新的对象来改变对象引用，StringBuilder 性能要比 StringBuffer 高 10%~15%，但是要冒着线程不安全的风险。</li><li>StringBuilder &gt; StringBuffer &gt; String（性能）</li></ul></li><li>总结：<ul><li>操作少量数据：String</li><li>单线程下大量数据：StringBuilder</li><li>多线程下大量数据：StringBuffer</li></ul></li></ul></li></ul><h2 id="自动装箱、拆箱"><a href="#自动装箱、拆箱" class="headerlink" title="自动装箱、拆箱"></a>自动装箱、拆箱</h2><ul><li><p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来</p></li><li><p><strong>拆箱：</strong>将包装类型转换为基本数据类型</p></li></ul><h2 id="在一个静态方法内调用一个非静态成员为什么是非法的？"><a href="#在一个静态方法内调用一个非静态成员为什么是非法的？" class="headerlink" title="在一个静态方法内调用一个非静态成员为什么是非法的？"></a>在一个静态方法内调用一个非静态成员为什么是非法的？</h2><ul><li>静态方法属于类的本身，在类加载的时候就会分配内存，而非静态成员只有在类实例化时才会分配内存，静态方法不通过对象来调用，所以静态方法里，不能调用非静态成员</li></ul><h2 id="在-java-中定义一个不做事且没有参数的构造方法的作用："><a href="#在-java-中定义一个不做事且没有参数的构造方法的作用：" class="headerlink" title="在 java 中定义一个不做事且没有参数的构造方法的作用："></a>在 java 中定义一个不做事且没有参数的构造方法的作用：</h2><ul><li>java 程序在执行子类构造方法之前会执行父类的构造方法，每个构造方法都隐含着 super() ，如果父类只定义了有参的构造函数没有提供 无参的构造方法，则会报错</li></ul><h2 id="import-java和javax有什么区别？"><a href="#import-java和javax有什么区别？" class="headerlink" title="import java和javax有什么区别？"></a>import java和javax有什么区别？</h2><ul><li>以前 javax 是 java 包 的扩展，随着时间推移 javax 也成为 java api 的一部分，所以这俩现在没啥区别</li></ul><h2 id="接口和抽象类的区别？"><a href="#接口和抽象类的区别？" class="headerlink" title="接口和抽象类的区别？"></a>接口和抽象类的区别？</h2><ul><li>接口方法默认是 public ，java 8 开始接口方法可以有默认实现（default static），而抽象类也可以包含非抽象的方法</li><li>接口中的变量一定是 static final 的，抽象类中随意</li><li>抽象方法就是为了重写所以别定义成 private，剩下的随意</li><li>设计层面来看：<ul><li>抽象就是类的一种抽象，类似一个模板</li><li>而接口时类的行为的规范</li></ul></li></ul><h2 id="成员变量与局部变量的区别？"><a href="#成员变量与局部变量的区别？" class="headerlink" title="成员变量与局部变量的区别？"></a>成员变量与局部变量的区别？</h2><h3 id="语法上看"><a href="#语法上看" class="headerlink" title="语法上看"></a>语法上看</h3><ul><li>成员变量属于类，可以用访问控制符及 static 修饰</li><li>局部变量属于方法，不可以被上面这些修饰，但是两者都可以被 final 修饰</li></ul><h3 id="在内存的存储方式"><a href="#在内存的存储方式" class="headerlink" title="在内存的存储方式"></a>在内存的存储方式</h3><ul><li>成员变量 static 修饰，是属于类的</li><li>没有被 static 修饰，是属于实例对象的</li><li>对象存在 <strong>堆内存</strong>，局部变量存在 <strong>栈内存</strong></li></ul><h3 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h3><ul><li>成员变量随对象的创建而存在，是对象的一部分</li><li>局部变量随方法的调用而自动消失</li></ul><h3 id="初值"><a href="#初值" class="headerlink" title="初值"></a>初值</h3><ul><li>成员变量会自动赋初值（final除外）</li><li>局部变量不会</li></ul><h2 id="对象实体和对象引用的不同？"><a href="#对象实体和对象引用的不同？" class="headerlink" title="对象实体和对象引用的不同？"></a>对象实体和对象引用的不同？</h2><ul><li>new 创建对象实体，对象实体存在 <strong>堆内存</strong> 中</li><li>对象引用指向对象实体，存在 <strong>栈内存</strong> 中</li><li>对象引用可以指向 0 ~ 1 个</li><li>对象实体对象实体可以被 n 个对象引用</li></ul><h2 id="静态方法-和-实例方法-有何不同？"><a href="#静态方法-和-实例方法-有何不同？" class="headerlink" title="静态方法 和 实例方法 有何不同？"></a>静态方法 和 实例方法 有何不同？</h2><ul><li>静态方法属于类，不需要创建对象，里面只能访问静态成员变量，不能访问非静态的成员和方法</li></ul><h2 id="对象的相等-与-指向他们的引用相等-有何区别？"><a href="#对象的相等-与-指向他们的引用相等-有何区别？" class="headerlink" title="对象的相等 与 指向他们的引用相等 有何区别？"></a>对象的相等 与 指向他们的引用相等 有何区别？</h2><ul><li>对象相等：比较的是内存中存放的内容是否相等</li><li>对象引用的相等：比较的是指向的内存地址是否相等</li></ul><h2 id="与-equals-！！"><a href="#与-equals-！！" class="headerlink" title="== 与 equals ！！"></a><strong>== 与 equals ！！</strong></h2><h3 id><a href="#" class="headerlink" title="=="></a>==</h3><ul><li>比较的是内存地址，即两个对象是否一样，基本类型比较值，引用类型比较对象</li></ul><h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><p>其实就是提供一个能够供类重写的一个方法：</p><ul><li>没有重写的话与“==”一样比较内存地址</li><li>重写的话，比如 String 重写了 equals 比较的是内容是否一样，有自己的比较规则</li></ul><p><img alt="image-20191205002956559" data-src="https://cdn.kaiming66.com/image-20191205002956559.png" class="lazyload"></p><h2 id="hashCode-和-equals"><a href="#hashCode-和-equals" class="headerlink" title="hashCode 和 equals"></a>hashCode 和 equals</h2><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><ul><li>作用是获取 哈希码（散列码），确定该对象在哈希表中的位置，hashCode() 在 Object.java 类中</li><li>以 hashSet 如何检查重复来说：<ul><li>首先 通过 对象的 hashCode 来计算对象加入的位置，同时向其他对象的 hashCode 比较</li><li>如果没有则不重复，如果有 则调取对象的 equals 方法，再次判断内容是否相同</li><li>如果真相同，那么 hashSet 不会让他加入</li><li>这样的好处是减少了 equals 的使用次数，提高了运行速度</li><li>hashMap 与这类似 不过它 不允许 <strong>键</strong> 重复，hashSet 不允许 <strong>值</strong> 重复</li></ul></li><li><strong>hashCode</strong> 就是获取散列码，<strong>所以只在散列表中有用，在其他情况下没用</strong></li></ul><h3 id="hashCode-和-equals-的规定"><a href="#hashCode-和-equals-的规定" class="headerlink" title="hashCode 和 equals 的规定"></a>hashCode 和 equals 的规定</h3><ul><li>如果两个对象相同，则 hashCode 一定相同</li><li>两个对象的 hashCode 一样，也不一定相等（因为如果重写了 hashCode 的话，根据算法可能出现重复现象）</li><li>如果重写了 equals 方法那就必须得重写 hashCode 使得，equals返回 true 时，hashCode 必须返回 true</li><li>如果没重写过 hashCode 则不同对象的值永远不一样</li></ul><h2 id="Java只有值传递！！"><a href="#Java只有值传递！！" class="headerlink" title="Java只有值传递！！"></a>Java只有值传递！！</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">传递对象的引用不会改变，但是对象的属性可以改变。</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">"1"</span>);</span><br><span class="line">    list.add(<span class="string">"2"</span>);</span><br><span class="line">    System.out.println(list); <span class="comment">//1，2</span></span><br><span class="line">    change1(list);</span><br><span class="line">    System.out.println(list);<span class="comment">//1，2</span></span><br><span class="line">    change2(list);</span><br><span class="line">    System.out.println(list);<span class="comment">//1，2，3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change1</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">    list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change2</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">    list.add(<span class="string">"3"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>解释：<ul><li>如果是引用传递，那么 change1 的时候，会把 list 对象传进来，然后 new ArrayList<string>() 的时候，就会赋予 list 一个新的指向的地址，那么应该输出的是什么都没有，因为指向了新的内存空间。</string></li><li>而正因为是值传递，值传递就是复制自己一份传给形参，对象的话就会复制自己的内存地址给了 list 形参，然后这个 list 在 指向 new 之后，是不会影响到原本的 list 的，所以这里还是输出了 1,2</li><li>change2 就很好的说明了这点，因为传递的内存地址，所以 list.add 也确实加到了 实参 list 上面，所以输出 1,2,3</li></ul></li></ul><p><img alt="Image" data-src="https://cdn.kaiming66.com/image-20191204232024420.png" class="lazyload"></p><ul><li>上面这幅图如何解释？<ul><li>既然是传内存地址为何没变</li><li>因为大家都忽略了，String = “hollischuang” 时，如果常量池里没有的话，就相当于 new String(“ hollischuang”)</li><li>所以也是指向新的内存地址，原本的不会改变</li></ul></li></ul><h2 id="线程、程序、进程的基本概念，三者关系是什么？"><a href="#线程、程序、进程的基本概念，三者关系是什么？" class="headerlink" title="线程、程序、进程的基本概念，三者关系是什么？"></a>线程、程序、进程的基本概念，三者关系是什么？</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。<strong>与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源</strong>，所以系统在产生一个线程，或是<strong>在各个线程之间作切换工作时，负担要比进程小得多</strong>，也正因为如此，线程也被称为轻量级进程。</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p><strong>进程</strong>就是程序的一次执行过程，<strong>是系统运行程序的基本单位</strong>， 因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。<strong>从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</strong></p><h3 id="线程的基本状态"><a href="#线程的基本状态" class="headerlink" title="线程的基本状态"></a>线程的基本状态</h3><p><img alt="image-20191205110900503" data-src="https://cdn.kaiming66.com/image-20191205110900503.png" class="lazyload"></p><ul><li>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下：</li></ul><p><img alt="image-20191205110918737" data-src="https://cdn.kaiming66.com/image-20191205110918737.png" class="lazyload"></p><ul><li>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 start() 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</li><li><strong>操作系统隐藏 Java虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态**</strong>，所以 Java 系统一般将这两个状态统称为** <strong>RUNNABLE（运行中）</strong> <strong>状态 。</strong></li><li>当线程执行 wait()方法之后，线程进入 <strong>WAITING（等待）</strong>状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的run()方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</li></ul><h2 id="final-关键字总结"><a href="#final-关键字总结" class="headerlink" title="final 关键字总结"></a>final 关键字总结</h2><ul><li>用在三个地方：变量、方法、类</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>基本类型：则其数值初始化后不能改变</li><li>引用类型：初始化后不能指向其他对象</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>以前版本的原因：<ul><li>1.防止这个方法被继承</li><li>2.提高效率，final 方法会转为内嵌调用，但是如果方法过于庞大，就几乎没有性能提升</li><li>3.现在Java版本不需要这样优化了，private 定义的方法默认为 final，final定义属性的话没啥用，因为属性就不能被更改了</li></ul></li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul><li>即这个类不能被继承，里面所有方法默认为 final</li></ul><h2 id="Java的异常处理"><a href="#Java的异常处理" class="headerlink" title="Java的异常处理"></a>Java的异常处理</h2><p><img alt="image-20191205112046781" data-src="https://cdn.kaiming66.com/image-20191205112046781.png" class="lazyload"></p><ul><li>在 Java 中，所有的异常都有一个共同的祖先java.lang包中的 <strong>Throwable类</strong>。Throwable： 有两个重要的子类：<strong>Exception（异常）</strong> 和 <strong>Error（错误）</strong> ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。</li><li><strong>Error（错误）:是程序无法处理的错误</strong>，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</li><li><strong>Exception（异常）:是程序本身可以处理的异常</strong>。Exception 类有一个重要的子类 <strong>RuntimeException</strong>。RuntimeException 异常由Java虚拟机抛出。<strong>NullPointerException</strong>（要访问的变量没有引用任何对象时，抛出该异常）、<strong>ArithmeticException</strong>（算术运算异常，一个整数除以0时，抛出该异常）和 <strong>ArrayIndexOutOfBoundsException</strong> （下标越界异常）。</li><li><strong>异常和错误的区别：异常能被程序本身处理，错误是无法处理。</strong></li></ul><h3 id="Throwable-常用方法"><a href="#Throwable-常用方法" class="headerlink" title="Throwable 常用方法"></a>Throwable 常用方法</h3><ul><li>public string getMessage():返回异常发生时的简要描述</li><li>public string toString():返回异常发生时的详细信息</li><li>public string getLocalizedMessage():返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同</li><li>public void printStackTrace():在控制台上打印Throwable对象封装的异常信息</li></ul><h3 id="final-会覆盖-try-的-return-语句"><a href="#final-会覆盖-try-的-return-语句" class="headerlink" title="final 会覆盖 try 的 return 语句"></a>final 会覆盖 try 的 return 语句</h3><p><img alt="image-20191205112238180" data-src="https://cdn.kaiming66.com/image-20191205112238180.png" class="lazyload"></p><h2 id="Java-如果有些字段不想序列化怎么办？"><a href="#Java-如果有些字段不想序列化怎么办？" class="headerlink" title="Java 如果有些字段不想序列化怎么办？"></a>Java 如果有些字段不想序列化怎么办？</h2><ul><li>transient 字段来修饰变量，不能修饰类和方法</li><li>ArrayList 就用到了 transient 来只序列化有效元素，来提高效率</li><li>ArrayList 源码：</li></ul><p><img alt="image-20191205112314651" data-src="https://cdn.kaiming66.com/image-20191205112314651.png" class="lazyload"></p><p><img alt="image-20191205112322555" data-src="https://cdn.kaiming66.com/image-20191205112322555.png" class="lazyload"></p><ul><li>这里只把有效的元素序列化，提高效率</li></ul><h2 id="获取键盘输入的两种方法："><a href="#获取键盘输入的两种方法：" class="headerlink" title="获取键盘输入的两种方法："></a>获取键盘输入的两种方法：</h2><ul><li>Scanner</li></ul><p><img alt="image-20191205112410713" data-src="https://cdn.kaiming66.com/image-20191205112410713.png" class="lazyload"></p><ul><li>BufferedReader</li></ul><p><img alt="image-20191205112418895" data-src="https://cdn.kaiming66.com/image-20191205112418895.png" class="lazyload"></p><h2 id="Java-I-O-总结"><a href="#Java-I-O-总结" class="headerlink" title="Java I/O 总结"></a>Java I/O 总结</h2><ul><li>按照流向：输入流、输出流</li><li>按照操作单元：字节流、字符流</li><li>按照流的角色：节点流、处理流</li><li>Java IO 40 多个类，全部诞生于这 4 个类：<ul><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul></li></ul><p><img alt="image-20191205112514137" data-src="https://cdn.kaiming66.com/image-20191205112514137.png" class="lazyload"></p><ul><li>自己总结一下，带 Stream 的都是字节流，不带的 都是字符流</li></ul><p><img alt="image-20191205112526100" data-src="https://cdn.kaiming66.com/image-20191205112526100.png" class="lazyload"></p><h3 id="不同的读取方式的速度：批处理带缓冲-gt-批处理-gt-缓冲-gt-直接读取"><a href="#不同的读取方式的速度：批处理带缓冲-gt-批处理-gt-缓冲-gt-直接读取" class="headerlink" title="不同的读取方式的速度：批处理带缓冲&gt;批处理&gt;缓冲&gt;直接读取"></a>不同的读取方式的速度：批处理带缓冲&gt;批处理&gt;缓冲&gt;直接读取</h3><h3 id="既然有了字节流为什么还有字符流？（主要是应对编码问题）"><a href="#既然有了字节流为什么还有字符流？（主要是应对编码问题）" class="headerlink" title="既然有了字节流为什么还有字符流？（主要是应对编码问题）"></a>既然有了字节流为什么还有字符流？（主要是<strong>应对编码问题</strong>）</h3><ul><li>字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们<strong>不知道编码类型就很容易出现乱码问题</strong>。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</li></ul><h3 id="BIO、NIO、AIO的区别？"><a href="#BIO、NIO、AIO的区别？" class="headerlink" title="BIO、NIO、AIO的区别？"></a>BIO、NIO、AIO的区别？</h3><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p><strong>BIO (Blocking I/O):</strong> 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p><h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p><strong>NIO (New I/O):</strong> NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</p><h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><p><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</p><h2 id="深拷贝和浅拷贝："><a href="#深拷贝和浅拷贝：" class="headerlink" title="深拷贝和浅拷贝："></a>深拷贝和浅拷贝：</h2><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</p><h2 id="-1"><a href="#-1" class="headerlink" title></a><img alt="image-20191205113008514" data-src="https://cdn.kaiming66.com/image-20191205113008514.png" class="lazyload"></h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 Servlet + jsp + MySQL 实现博客管理系统</title>
      <link href="/2019/12/02/project/Java-Web-%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/12/02/project/Java-Web-%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Archivev/blog" target="_blank" rel="noopener">博客管理</a></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>教你搭建 hexo 博客并通过 ngnix 部署到服务器上</title>
      <link href="/2019/12/01/blog/createBlog/"/>
      <url>/2019/12/01/blog/createBlog/</url>
      
        <content type="html"><![CDATA[<h1 id="教你搭建-hexo-博客并通过-ngnix-部署到服务器上"><a href="#教你搭建-hexo-博客并通过-ngnix-部署到服务器上" class="headerlink" title="教你搭建 hexo 博客并通过 ngnix 部署到服务器上"></a>教你搭建 hexo 博客并通过 ngnix 部署到服务器上</h1><p>国际惯例搭好一个博客先写个搭建教程。</p><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>首先 hexo 基于 node.js 运行所以我们要先在 linux 服务器上安装上 node.js 环境</p><p><img alt="image-20191130183049459" data-src="http://cdn.kaiming66.com/createBlog-20191130183049459.png" class="lazyload"></p><ul><li><p>下载链接：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p></li><li><p>下载到本地你的电脑上：</p></li></ul><p><img alt="image-20191130233245444" data-src="http://cdn.kaiming66.com/createBlog-20191130233245444.png" class="lazyload"></p><ul><li>然后我们通过 XShell 连接你的服务器，我这里用的是 阿里云，然后执行下面两句创建一个放 node.js 的文件夹</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt</span><br><span class="line">mkdir nodeJs</span><br></pre></td></tr></table></figure><ul><li>下载到本地后，我们上传到服务器上，我这里使用的是 XFtp 上传</li></ul><p><img alt="image-20191130234037218" data-src="http://cdn.kaiming66.com/createBlog-20191130234037218.png" class="lazyload"></p><ul><li>然后在服务器这找到刚才的上传的文件，并解压</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf node-v12.13.1-linux-x64.tar.xz</span><br><span class="line">mv node-v12.13.1-linux-x64.tar.xz nodejs</span><br></pre></td></tr></table></figure><p><img alt="image-20191130234308603" data-src="http://cdn.kaiming66.com/createBlog-20191130234308603.png" class="lazyload"></p><ul><li>接下来我们把它加到环境里</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><ul><li>按 i 键进入编辑模式，在最后一行的后面添加如下所示的语句（后面写你自己创建的文件的路径）</li></ul><p><img alt="image-20191130234456112" data-src="http://cdn.kaiming66.com/createBlog-20191130234456112.png" class="lazyload"></p><ul><li>使配置文件生效</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><ul><li>验证是否安装成功</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><ul><li>能正常显示版本信息则安装成功，接下来我们来配置一下 淘宝的源，这样会提高下载速度</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><ul><li>同理 cnpm -v 确认是否安装成功（正常显示版本则成功）</li><li>然后下载 hexo </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-cli</span><br></pre></td></tr></table></figure><ul><li>然后我们随便选择一个地方初始哈我们的博客的文件夹，我这里选的是 root 目录下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span></span><br><span class="line">mkdir blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure><p><img alt="image-20191130235152238" data-src="http://cdn.kaiming66.com/createBlog-20191130235152238.png" class="lazyload"></p><ul><li><p>显示图上信息则初始化成功</p></li><li><p>我们用 ls 命令查看一下 blog 文件夹下 hexo 帮我们创建了什么文件</p></li></ul><p>我们 ls 查看一下</p><p><img alt="img" data-src="http://cdn.kaiming66.com/createBlog-image%286%29.png" class="lazyload"></p><ul><li>简单介绍一下：<ul><li>第一个 config.yml 是 hexo 的配置文件以后要用到</li><li>themes 里面放的是主题的文件</li><li>source 以后会用来存放你写的博客</li></ul></li><li>这些都是初始化生成的文件我们在 blog 文件夹内输入启动 hexo 的命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p><img alt="img" data-src="http://cdn.kaiming66.com/createBlog-20191130183700057.png" class="lazyload"></p><ul><li><p>出现如下信息则证明，hexo 已经在你的 4000 端口号 部署完成了</p></li><li><p>我们通过服务器访问一下</p></li></ul><p><img alt="image-20191130235554710" data-src="http://cdn.kaiming66.com/createBlog-20191130235554710.png" class="lazyload"></p><ul><li>这样前面加上自己服务器的 ip 地址，后面冒号加 4000 的端口号访问，成功页面如上（这里我改了一下标题）</li><li>要修改启动端口的话，想要改为 80 端口，则输入 hexo s -p 80 命令即可</li></ul><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><ul><li>我的 blog 使用的主题是 Butterfly 主题，个人很喜欢，你也可以去 github 上找其他的主题</li><li>首先你需要下载一个 git （这个后面还会用到） </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure><ul><li>然后 clone 主题（这步要在一开始建的 hexo 初始化的目录 blog 目录下进行）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;jerryc127&#x2F;hexo-theme-butterfly.git themes&#x2F;Butterfly</span><br></pre></td></tr></table></figure><ul><li>clone 完成以后，我们到 blog 文件夹下的 _config.yml 修改一下主题</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim _config.yml</span><br></pre></td></tr></table></figure><p><img alt="image-20191201001431694" data-src="http://cdn.kaiming66.com/createBlog-20191201001431694.png" class="lazyload"></p><ul><li>进入后一直往下找，找到下图位置，修改为 Butterfly，如果你是别的主题那就写上别的主题的名字</li></ul><p><img alt="image-20191201001513009" data-src="http://cdn.kaiming66.com/createBlog-20191201001513009.png" class="lazyload"></p><ul><li><p>改为上图即可，与冒号中间有空格</p></li><li><p>接下来，hexo 更新配置后的素质三连</p><ul><li>hexo clean       这个是清除掉已生成的文件</li><li>hexo g              这个是根据你的改动生成新的文件</li><li>hexo s -p 80     开启 hexo server，绑定到 80 端口</li></ul></li><li><p>等启动完成后访问你的域名或者你的服务器 ip 地址</p></li><li><p>我这里访问就出现了问题：</p></li></ul><p><img alt="image-20191201001947378" data-src="http://cdn.kaiming66.com/createBlog-20191201001947378.png" class="lazyload"></p><ul><li>网页打开无法渲染页面，不要慌输入下面的命令安装渲染组件（这是一条命令太长了，不是两条！！）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-jade hexo-renderer-stylus --save or yarn add hexo-renderer-jade hexo-renderer-stylus</span><br></pre></td></tr></table></figure><p><img alt="image-20191201002157494" data-src="http://cdn.kaiming66.com/createBlog-20191201002157494.png" class="lazyload"></p><ul><li>等待安装完成后输入 hexo s -p 80，再去访问</li></ul><p><img alt="image-20191201002239482" data-src="http://cdn.kaiming66.com/createBlog-20191201002239482.png" class="lazyload"></p><ul><li>OK 到这里主题也就完成更换了，觉得不好看再去挑几个嘛。</li></ul><h2 id="部署到-Nginx上"><a href="#部署到-Nginx上" class="headerlink" title="部署到 Nginx上"></a>部署到 Nginx上</h2><ul><li>我们发现 hexo 在运行的时候，终端一直被挂起无法干别的事，去百度了一圈找到了好几种方法<ul><li>第一种是比较简单通过 node.js 的 forever 实现<br>参考链接：<a href="http://www.tuijiankan.com/2015/05/08/hexo-forever-run/" target="_blank" rel="noopener">http://www.tuijiankan.com/2015/05/08/hexo-forever-run/</a></li><li>第二种是使用 pm2 来实现<br>参考链接：<a href="https://blog.csdn.net/sinat_18268881/article/details/91353032" target="_blank" rel="noopener">https://blog.csdn.net/sinat_18268881/article/details/91353032</a></li><li>第三种就是使用的 Nginx 来实现，接下来我们重点说这个</li></ul></li></ul><h3 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h3><ul><li>首先安装 nginx</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nginx</span><br></pre></td></tr></table></figure><ul><li>安装完成后配置一下 nginx</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><ul><li>找到如下：</li></ul><p><img alt="image-20191201110214816" data-src="http://cdn.kaiming66.com/createBlog-20191201110214816.png" class="lazyload"></p><ul><li>这里原本是 nginx，我们把它改成 root</li></ul><p><img alt="image-20191201003709459" data-src="http://cdn.kaiming66.com/createBlog-20191201003709459.png" class="lazyload"></p><ul><li>server_name 后面填你域名或者服务器的 ip</li><li>root  这里的 /data/www/hexo  是 nginx 的web 项目路径，会访问到里面的 index.html 页面</li><li>然后重启 nginx </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><h3 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h3><ul><li>首先下个 hexo 关于 git 的管理插件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ul><li>创建 /data/www/hexo目录，用于存放博客生成的静态文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /</span><br><span class="line">mkdir data</span><br><span class="line"><span class="built_in">cd</span> data</span><br><span class="line">mkdir www</span><br><span class="line"><span class="built_in">cd</span> www</span><br><span class="line">mkdir hexo</span><br></pre></td></tr></table></figure><ul><li>然后创建 /data/GitLibrary 目录，用于托管文件项目。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data</span><br><span class="line">mkdir GitLibrary</span><br></pre></td></tr></table></figure><ul><li>初始化 git 仓库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init --bare hexo.git</span><br></pre></td></tr></table></figure><ul><li>利用 git hooks （钩子函数）创建一个脚本，post-recive 脚本将在 <strong>blog.git</strong>仓库接收到 push 时执行。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /data/GitLibrary/hexo.git/hooks/post-receive</span><br></pre></td></tr></table></figure><ul><li>内容添加为：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GIT_REPO=/data/GitLibrary/hexo.git    <span class="comment"># git仓库</span></span><br><span class="line">PUBLIC_WWW=/data/www/hexo             <span class="comment"># 网站目录</span></span><br><span class="line">TMP_GIT_CLONE=/tmp/hexo</span><br><span class="line"></span><br><span class="line">rm -rf <span class="variable">$&#123;TMP_GIT_CLONE&#125;</span></span><br><span class="line">git <span class="built_in">clone</span> <span class="variable">$GIT_REPO</span> <span class="variable">$TMP_GIT_CLONE</span></span><br><span class="line">rm -rf <span class="variable">$&#123;PUBLIC_WWW&#125;</span>/*</span><br><span class="line">cp -rf <span class="variable">$&#123;TMP_GIT_CLONE&#125;</span>/* <span class="variable">$&#123;PUBLIC_WWW&#125;</span></span><br></pre></td></tr></table></figure><ul><li>保存并退出，然后执行下面代码，赋予脚本执行的权限</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x post-receive</span><br></pre></td></tr></table></figure><h3 id="配置-Hexo"><a href="#配置-Hexo" class="headerlink" title="配置 Hexo"></a>配置 Hexo</h3><ul><li>上面的步骤操作完后，打开 hexo根目录下的 _confi.yml，拉到最下面</li></ul><p><img alt="image-20191201110439010" data-src="http://cdn.kaiming66.com/createBlog-20191201110439010.png" class="lazyload"></p><ul><li>格式：用户名@域名或 IP 地址:/data/GitLibrary/hexo<ul><li>这里的用户名是你服务器的，一般来说都是 root</li><li>@后面加上你的域名或者 ip</li><li>后面如果上面步骤一致则就是 /data/GitLibrary/hexo 不用改</li></ul></li><li>然后我们来个 素质二连<ul><li>hexo clean    这个还是清除已生成的文件</li><li>hexo g -d      这个命令就是 hexo g  +  hexo d 意思就是先生成，再推到 git 上去</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>基本步骤应该没有啥大问题，中间我也是踩了很多的坑，不过总体来说要比我上次搭的 lnmp + wordpress 快上一百倍了。。。</p><p>最后感谢 <a href="https://xiaoyou66.com/" target="_blank" rel="noopener">小游</a> <a href="https://blog.shuifengche.top/" target="_blank" rel="noopener">水风车</a> ，一开始也只是在知乎上闲逛，看见 有了自己一台服务器能干什么 后，看见了小游大佬的回答，突然感觉自己好像白学计算机了，而且搭个博客也是我一直想做的事，今天终于算是真正实现啦！</p><p>8 月份的时候搭过一个无奈太过复杂（好吧还是我太菜了 2333），接下来也会跟着大佬的脚步，弄个云盘，弄个图床什么的研究一下 cdn 也行 ，反正就是好好搞了。</p><p>如果还有什么问题我这里没有说清楚的，可以看下面的链接，我基本上都是看着链接自己弄的，应该可以解决大部分问题。</p><p>附上参考链接：</p><ul><li><a href="http://60.205.218.74/2019/04/06/将Hexo部署在自己的服务器上/" target="_blank" rel="noopener">将Hexo部署在自己的服务器上</a></li><li><a href="https://www.jianshu.com/p/ad98b5cb1562" target="_blank" rel="noopener">VPS配置Git Hooks实现hexo博客更新</a></li><li><a href="https://www.jianshu.com/p/67c57c70f275" target="_blank" rel="noopener">hexo 部署至Git遇到的坑</a></li><li><a href="https://www.bilibili.com/video/av44544186" target="_blank" rel="noopener">codesheep教你搭建hexo博客|无坑版</a></li><li><a href="https://www.jianshu.com/p/196773379a78" target="_blank" rel="noopener">如何在个人服务器上部署Hexo博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
